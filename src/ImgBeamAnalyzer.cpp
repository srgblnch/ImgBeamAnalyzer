//*******************************************************************************
//* Copyright (c) 2004-2014 Synchrotron SOLEIL
//* All rights reserved. This program and the accompanying materials
//* are made available under the terms of the GNU Lesser Public License v3
//* which accompanies this distribution, and is available at
//* http://www.gnu.org/licenses/lgpl.html
//******************************************************************************
static const char *RcsId = "$Header: /users/chaize/newsvn/cvsroot/Calculation/ImgBeamAnalyzer/src/ImgBeamAnalyzer.cpp,v 1.53 2013-01-04 17:34:06 flanglois Exp $";
//+=============================================================================
//
// file :         ImgBeamAnalyzer.cpp
//
// description :  C++ source for the ImgBeamAnalyzer and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                ImgBeamAnalyzer are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: flanglois $
//
// $Revision: 1.53 $
//
// $Log: not supported by cvs2svn $
// Revision 1.50  2012/03/30 18:23:15  buteau
// MANTIS 0022238
//
// Revision 1.48  2011/08/17 13:38:21  nleclercq
// removed asserts
// events fired if and only if mode == EVENT
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//      This file is generated by POGO
//  (Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name         |  Method name
//	----------------------------------------
//  State                |  dev_state()
//  Status               |  dev_status()
//  Start                |  start()
//  Stop                 |  stop()
//  Process              |  process()
//  SaveCurrentSettings  |  save_current_settings()
//  GetVersionNumber     |  get_version_number()
//
//===================================================================


#include <ImgBeamAnalyzer.h>
#include <ImgBeamAnalyzerClass.h>
#include <limits>
#include <ImgBeamAnalyzerVersion.h>
#include <yat4tango/ExceptionHelper.h>
#ifdef WIN32
#include <Windows.h>
#endif

#define kDEFAULT_CONTINUOUS_TIMEOUT 1000
#define kCOMMAND_TIMEOUT 2000

namespace ImgBeamAnalyzer_ns
{

template <> Tango::DevBoolean ImgBeamAnalyzer::DummyValue<Tango::DevBoolean>::dummy = std::numeric_limits<bool>::quiet_NaN();
template <> Tango::DevUChar   ImgBeamAnalyzer::DummyValue<Tango::DevUChar>  ::dummy = std::numeric_limits<unsigned char>::quiet_NaN();
template <> Tango::DevUShort  ImgBeamAnalyzer::DummyValue<Tango::DevUShort> ::dummy = std::numeric_limits<unsigned short>::quiet_NaN();
template <> Tango::DevLong    ImgBeamAnalyzer::DummyValue<Tango::DevLong>   ::dummy = std::numeric_limits<yat_int32_t>::quiet_NaN();
template <> Tango::DevULong   ImgBeamAnalyzer::DummyValue<Tango::DevULong>  ::dummy = std::numeric_limits<yat_uint32_t>::quiet_NaN();
template <> Tango::DevFloat   ImgBeamAnalyzer::DummyValue<Tango::DevFloat>  ::dummy = std::numeric_limits<float>::quiet_NaN();
template <> Tango::DevDouble  ImgBeamAnalyzer::DummyValue<Tango::DevDouble> ::dummy = std::numeric_limits<double>::quiet_NaN();


// ---------------------------------------------------------------------------------------
// OP 07/07/2014 :
// Define TANGO_MUTEX to have a mutex protection during the Tango attributes serialization
// Define OUTPUT_DEBUG to have some debug trace in VC Output Window
// ---------------------------------------------------------------------------------------
#ifdef TANGO_MUTEX

#define INTERNAL_LOCK_AD m_AvailableDataListMutex.lock();
#define INTERNAL_UNLOCK_AD m_AvailableDataListMutex.unlock();
#define INTERNAL_ATTRUNLOCK_AD attr.set_user_attr_mutex(&m_AvailableDataListMutex);

#else

#define INTERNAL_LOCK_AD m_AvailableDataListMutex.lock();
#define INTERNAL_UNLOCK_AD m_AvailableDataListMutex.unlock();
#define INTERNAL_ATTRUNLOCK_AD m_AvailableDataListMutex.unlock();

#endif  //TANGO_MUTEX

#define LOCK_AD \
  INTERNAL_LOCK_AD\
	FUNC_LOCK_AD_TRACE

#define UNLOCK_AD \
  INTERNAL_UNLOCK_AD\
	FUNC_UNLOCK_AD_TRACE

#define ATTRUNLOCK_AD \
  INTERNAL_ATTRUNLOCK_AD\
	FUNC_ATTRUNLOCK_AD_TRACE

#ifdef OUTPUT_DEBUG

#define ENTER_FUNC \
	OutputDebugString("=>Enter ");\
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("\r\n");

#define LEAVE_FUNC\
	OutputDebugString("<=Leave ");\
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("\r\n");

#define FUNC_LOCK_AD_TRACE \
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("Lock\r\n");

#define FUNC_UNLOCK_AD_TRACE \
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("Unlock\r\n");

#ifdef TANGO_MUTEX
#define FUNC_ATTRUNLOCK_AD_TRACE \
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("SettAttrUnlock\r\n");
#else
#define FUNC_ATTRUNLOCK_AD_TRACE \
	OutputDebugString(__FUNCTION__);\
	OutputDebugString("Unlock\r\n");
#endif  //TANGO_MUTEX

#else

#define ENTER_FUNC
#define LEAVE_FUNC
#define FUNC_LOCK_AD_TRACE
#define FUNC_UNLOCK_AD_TRACE
#define FUNC_ATTRUNLOCK_AD_TRACE

#endif

#define READ_OUTPUT_SCALAR_ATTR_ALWAYSACTIV( data_member, TangoType )          \
  {     \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0                                               \
         || &pLastAvailableData->data_member == 0)                          \
    {                                                                          \
	    UNLOCK_AD\
      attr.set_value(&DummyValue<TangoType>::dummy);                           \
      attr.set_quality(Tango::ATTR_ALARM);                                     \
    }                                                                          \
    else                                                                       \
    {                                                                          \
      attr.set_value(reinterpret_cast<TangoType*>                              \
                                        (&pLastAvailableData->data_member));\
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm == true)                                \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }    \
    LEAVE_FUNC\
  }

#define READ_OUTPUT_SCALAR_ATTR( data_member, activated, TangoType )           \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0                                             \
         || pLastAvailableData->config.activated == false                   \
		 || &pLastAvailableData->data_member == 0)                          \
    {                                                                          \
	  UNLOCK_AD\
      attr.set_value(&DummyValue<TangoType>::dummy);                           \
      attr.set_quality(Tango::ATTR_ALARM);                                     \
    }                                                                          \
    else                                                                       \
    {                                                                          \
      attr.set_value(reinterpret_cast<TangoType*>                              \
                                        (&pLastAvailableData->data_member));\
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm == true)                                \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }                                                                          \
    LEAVE_FUNC\
  }

#define READ_OUTPUT_SPECTRUM_ATTR( data_member, activated, TangoType )         \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0                                             \
         || pLastAvailableData->config.activated == false                   \
         || pLastAvailableData->data_member.base() == 0 )                   \
    {                                                                          \
	  UNLOCK_AD\
      attr.set_value(&DummyValue<TangoType>::dummy, 1, 0);                     \
      attr.set_quality(Tango::ATTR_ALARM);                                     \
    }                                                                          \
    else                                                                       \
    {                                                                          \
      attr.set_value(pLastAvailableData->data_member.base(),                \
                     static_cast<yat_int32_t>                                  \
                                (pLastAvailableData->data_member.length()));\
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm == true)                                \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }                                                                          \
    LEAVE_FUNC\
  }

#define READ_OUTPUT_IMAGE_ATTR_ALWAYSACTIV( data_member, TangoType )           \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0                                             \
         || pLastAvailableData->data_member.base() == 0 )                   \
    {                                                                          \
	  UNLOCK_AD\
      attr.set_value(&DummyValue<TangoType>::dummy, 1, 1);                     \
      attr.set_quality(Tango::ATTR_ALARM);                                     \
    }                                                                          \
    else                                                                       \
    {                                                                          \
      attr.set_value(pLastAvailableData->data_member.base(),                \
                     static_cast<yat_int32_t>                                  \
                                (pLastAvailableData->data_member.width()),  \
                     static_cast<yat_int32_t>                                  \
                              (pLastAvailableData->data_member.height()));  \
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm == true)                                \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }                                                                          \
    LEAVE_FUNC\
  }

#define READ_OUTPUT_IMAGE_ATTR( data_member, activated, TangoType )            \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0                                             \
         || pLastAvailableData->config.activated == false                   \
         || pLastAvailableData->data_member.base() == 0 )                   \
    {                                                                          \
	  UNLOCK_AD\
      attr.set_value(&DummyValue<TangoType>::dummy, 1, 1);                     \
      attr.set_quality(Tango::ATTR_ALARM);                                     \
    }                                                                          \
    else                                                                       \
    {                                                                          \
      attr.set_value(pLastAvailableData->data_member.base(),                \
                     static_cast<yat_int32_t>                                  \
                                  (pLastAvailableData->data_member.width()),\
                     static_cast<yat_int32_t>                                  \
                                (pLastAvailableData->data_member.height()));\
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm == true)                                \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }                                                                          \
    LEAVE_FUNC\
  }

#define READ_INPUT_ATTR( config_member_name, TangoType )                       \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0 || this->get_state() == Tango::FAULT)       \
  	{\
      attr.set_value(reinterpret_cast<TangoType*>                               \
                                  (&this->current_config_.config_member_name));\
      UNLOCK_AD\
	  }\
    else                       \
	  {\
      attr.set_value(reinterpret_cast<TangoType*>                                \
                          (&pLastAvailableData->config.config_member_name));\
      ATTRUNLOCK_AD\
	  }\
    LEAVE_FUNC\
  }

#define READ_INPUT_ATTR_WITH_ALARM(config_member_name,alarm_boolean,TangoType) \
  {                                                                            \
    ENTER_FUNC\
    BIAData* pLastAvailableData = NULL;\
    LOCK_AD\
    if (m_AvailableDataList.size() > 0)\
      pLastAvailableData = m_AvailableDataList.front();\
    if (pLastAvailableData == 0 || this->get_state() == Tango::FAULT)       \
	{\
      attr.set_value(reinterpret_cast<TangoType*>                              \
                                  (&this->current_config_.config_member_name));\
      UNLOCK_AD\
    }\
    else                                                                       \
    {                                                                          \
      attr.set_value(reinterpret_cast<TangoType*>                              \
                          (&pLastAvailableData->config.config_member_name));\
      ATTRUNLOCK_AD\
      if (pLastAvailableData->alarm_boolean == true)                        \
        attr.set_quality(Tango::ATTR_ALARM);                                   \
      else                                                                     \
        attr.set_quality(Tango::ATTR_VALID);                                   \
    }                                                                          \
    LEAVE_FUNC\
  }


#define WRITE_INPUT_ATTR( config_member_name, TangoType )                      \
  {                                                                            \
    ENTER_FUNC\
    if (this->task_ == 0)                                                      \
      return;                                                                  \
                                                                               \
    TangoType value;                                                           \
    attr.get_write_value (value);                                              \
     if (value !=  this->current_config_.config_member_name)                   \
    {                                                                          \
      BIAConfig new_config(this->current_config_);                             \
      new_config.config_member_name = value;                                   \
      try                                                                      \
      {                                                                        \
        new_config.validate();                                                 \
        this->task_->configure(new_config);                                    \
      }                                                                        \
      catch (yat::Exception &ex)                                               \
      {                                                                        \
        yat4tango::YATDevFailed df(ex);                                        \
        RETHROW_DEVFAILED(df,                                                  \
                          "SOFTWARE_FAILURE",                                  \
                          "Tango error during configuration",                  \
                          "ImgBeamAnalyzer::write_" #config_member_name);      \
      }                                                                        \
      catch(...)                                                               \
      {                                                                        \
        THROW_DEVFAILED("UNKNOWN_ERROR",                                       \
                        "Tango error during configuration",                    \
                        "ImgBeamAnalyzer::write_" #config_member_name);        \
      }                                                                        \
      this->current_config_ = new_config;                                      \
      try                                                                      \
      {                                                                        \
          DEBUG_STREAM << "memorize_attribute(" << attr.get_name() << "); ";   \
          Tango::Database *db = new Tango::Database();                         \
          Tango::DbData db_data;                                               \
          Tango::DbDatum dev_prop(attr.get_name());                            \
          dev_prop << value;                                                   \
          db_data.push_back(dev_prop);                                         \
          db->put_device_property(this->get_name(), db_data);                  \
      }                                                                        \
      catch(...)                                                               \
      {                                                                        \
          ERROR_STREAM << "Exception! when trying to memorize" << std::endl;   \
          THROW_DEVFAILED("UNKNOWN_ERROR",                                     \
                          "Tango error during memorize attribute",             \
                          "ImgBeamAnalyzer::write_" #config_member_name);      \
      }                                                                        \
    }                                                                          \
    LEAVE_FUNC\
  }



//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::ImgBeamAnalyzer(string &s)
// 
// description :   constructor for simulated ImgBeamAnalyzer
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
ImgBeamAnalyzer::ImgBeamAnalyzer(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
  init_device();
}

ImgBeamAnalyzer::ImgBeamAnalyzer(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
  init_device();
}

ImgBeamAnalyzer::ImgBeamAnalyzer(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
  init_device();
}
//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::delete_device()
// 
// description :   will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::delete_device()
{
   // Delete device's allocated object
  if (this->task_) {
    try
    {
      //- ask the task to quit
      this->task_->exit();
    }
    catch(Tango::DevFailed &ex)
    {
      ERROR_STREAM << ex << std::endl;
      //- ignore error
    }
    catch(...)
    {
      ERROR_STREAM << "Unknown exception caught when exiting task" << std::endl;
      //- ignore error
    }
    this->task_ = 0;
  }
  
  CleanAvailableList();

  delete this->image_source_;
  this->image_source_ = 0;
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::init_device()
// 
// description :   will be called at device initialization.
//ï¿½
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::init_device()
{
  INFO_STREAM << "ImgBeamAnalyzer::ImgBeamAnalyzer() create device " << device_name << endl;

  // Initialise variables to default values
  //--------------------------------------------
  cvUseOptimized( 0 );

  this->image_source_ = 0;
  this->task_ = 0;
  this->critical_property_missing_ = false;
  this->properly_initialized_ = false;
  this->image_counter_ = 0;
  this->process_command_allowed_ = false;
  this->process_command_waiting_ = false;

  try
  {
    this->get_device_property();
  }
  catch (Tango::DevFailed &df)
  {
    ERROR_STREAM << df << std::endl;
    this->set_status ("Initialization error [Tango Exception caught while getting device properties]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "Initialization error [Unknown Exception caught while getting device properties]" << std::endl;
    this->set_status ("Initialization error [Unknown Exception caught while getting device properties]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  if (this->critical_property_missing_ == true)
  {
    ERROR_STREAM << "Initialization error [unspecified critical device property]" << std::endl;
    this->set_status ("Initialization error [unspecified critical device property]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  if (this->mode == "oneshot")
    this->device_mode_ = MODE_ONESHOT;
  else if (mode == "continuous")
    this->device_mode_ = MODE_CONTINUOUS;
  else if (mode == "event")
    this->device_mode_ = MODE_EVENT;
  else
  {
    ERROR_STREAM << "Initialization error [Mode property must be ONESHOT or CONTINUOUS or EVENT]" << std::endl;
    this->set_status ("Initialization error [Mode property must be ONESHOT or CONTINUOUS or EVENT]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  bool dev_proxy_allowed = true;

  if (this->device_mode_ == MODE_CONTINUOUS || this->device_mode_ == MODE_EVENT)
  {
    if ( this->imageDevice == "unspecified")
    {
      ERROR_STREAM << "Initialization error [ImageDevice property not set]" << std::endl;
      this->set_status ("Initialization error [ImageDevice property not set]");
      this->set_state (Tango::FAULT);
      this->delete_device();
      return;
    }
    if ( this->imageAttributeName == "unspecified")
    {
      ERROR_STREAM << "Initialization error [ImageAttributeName property not set]" << std::endl;
      this->set_status ("Initialization error [ImageAttributeName property not set]");
      this->set_state (Tango::FAULT);
      this->delete_device();
      return;
    }
    dev_proxy_allowed = true;
    if (this->device_mode_ == MODE_CONTINUOUS)
    { 
       //- in CONTINUOUS mode, 'Process' command is disabled
       this->process_command_allowed_ = false;
    }
  }
  else
  {
    if ( this->imageDevice == "unspecified" || this->imageAttributeName == "unspecified")
    {
      //- no remote device specified : no command allowed
      //- the user must use write_InputImage
      dev_proxy_allowed = false;

      //- in ONESHOT mode, 'Process' command is disabled if a remote device is not specified
      //- In that case, the user can only use the write_InputImage method to interact with the device.
      this->process_command_allowed_ = false;
    }
    else
    {
      dev_proxy_allowed = true;
      this->process_command_allowed_ = true;
    }
  }

  if (dev_proxy_allowed)
  {
    try
    {
      this->image_source_ = IBASourceFactory::create(this->imageDevice);
      this->image_source_->set_image_attribute_name(this->imageAttributeName);
    }
    catch( Tango::DevFailed& df )
    {
      ERROR_STREAM << df << std::endl;
      this->set_status ("Initialization error [Tango Exception caught while instantiating DeviceProxy]");
      this->set_state (Tango::FAULT);
      this->delete_device();
      return;
    }
    catch(...)
    {
      ERROR_STREAM << "unknown exception caught during instantiation of DeviceProxy" << std::endl;
      this->set_status ("Initialization error [unknown exception caught while instantiating DeviceProxy]");
      this->set_state (Tango::FAULT);
      this->delete_device();
      return;
    }
  }


  // Init ImgBeamAnalyzerTask
  //--------------------------------------------  
  try
  {
    this->task_ = new ImgBeamAnalyzerTask ();
    if (this->task_ == 0)
      throw std::bad_alloc();

    ImgBeamAnalyzerInit init_config;

    //- this function will be called to get the image from the remote device
    if (this->image_source_)
      init_config.get_img = GetImgCB::instanciate(*this->image_source_, &IBASource::get_image);

    //- this function will be called when an image has been processed
    init_config.img_processed_cb = ImgProcessedCB::instanciate(*this, &ImgBeamAnalyzer::on_image_processed);
    //- is the previous function authorized (a proxy has been configured ?)
    init_config.get_img_allowed = dev_proxy_allowed;
    //- the initial processing parameters, from the device properties
    init_config.processing_config = this->current_config_;
    //- if in CONTINUOUS mode, auto start the processing ?
    init_config.auto_start = this->autoStart;
    //- the mode ( CONTINUOUS or ONE_SHOT or EVENT)
    init_config.mode = this->device_mode_;

    yat::Message* init_msg = yat::Message::allocate(yat::TASK_INIT, INIT_MSG_PRIORITY, true);
    init_msg->attach_data(init_config);
    this->task_->go(init_msg);
  }
  catch (const std::bad_alloc &)
  {
    ERROR_STREAM << "std::bad_alloc caught during instantiation of ImgBeamAnalyzerTask" << std::endl;
    this->set_status ("Initialization error [OUT_OF_MEMORY exception caught while instantiating ImgBeamAnalyzerTask]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }
  catch (yat::Exception& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]";
    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    this->delete_device ();
    return;
  }
  catch (...)
  {
    ERROR_STREAM << "unknown exception caught during instantiation of ImgBeamAnalyzerTask" << std::endl;
    this->set_status ("Initialization error [unknown exception caught while instantiating ImgBeamAnalyzerTask]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  if (dev_proxy_allowed) {

      string attr2subscribe = "";
      if ( this->imageCounterAttrName == "unspecified")
      {
        attr2subscribe = this->imageAttributeName;
        INFO_STREAM << "Subscription via Image: " << this->imageDevice << "/" << this->imageAttributeName << std::endl;
      }
      else
      {
        attr2subscribe = this->imageCounterAttrName;
        INFO_STREAM << "Subscription via Counter: " << this->imageDevice << "/" << this->imageCounterAttrName << std::endl;
      }

      if (this->device_mode_ == MODE_EVENT)
      {
        if (this->image_source_)
        {
          this->image_source_->set_callback_attribute(attr2subscribe);
          if (this->autoStart)
            this->image_source_->register_observer(this);
        }
        this->process_command_allowed_ = true;
        INFO_STREAM << "Well subscribed to the ImageCounter: " << this->imageDevice << "/" << this->imageCounterAttrName \
                    << ", for the image: " << this->imageDevice << "/" << this->imageAttributeName << std::endl;
      }
  }
  
  this->properly_initialized_ = true;

  //- update the state
  this->always_executed_hook();
}


//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::get_device_property()
// 
// description :   Read the device properties from database.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::get_device_property()
{
  //  Initialize your default values here (if not done with  POGO).
  //------------------------------------------------------------------
  this->imageDevice = "unspecified";
  this->imageAttributeName = "unspecified";
  this->imageCounterAttrName = "unspecified";
  this->autoStart = false;
  this->mode = "unspecified";
  this->autoROIMethod = "unspecified";

  
  //- Generate a default configuration object
  BIAConfig default_config;

  this->computationPeriod    = default_config.comput_period;
  this->enableImageStats     = default_config.enable_image_stats;
  this->enableProfiles       = default_config.enable_profile;
  this->enableHistogram      = default_config.enable_histogram;
  this->enableUserROI        = default_config.enable_user_roi;
  this->enableAutoROI        = default_config.enable_auto_roi;
  this->enable2DGaussianFit  = default_config.enable_2d_gaussian_fit;
  this->autoROIMagFactorX    = default_config.auto_roi_mag_factor_x;
  this->autoROIMagFactorY    = default_config.auto_roi_mag_factor_y;
  this->pixelSizeX           = default_config.pixel_size_x;
  this->pixelSizeY           = default_config.pixel_size_y;
  this->opticalMagnification = default_config.optical_mag;
  this->userROIOriginX     = default_config.user_roi_origin_x;
  this->userROIOriginY     = default_config.user_roi_origin_y;
  this->userROIWidth         = default_config.user_roi_width;
  this->userROIHeight        = default_config.user_roi_height;    
  this->profileFitFixedBg    = default_config.profilefit_fixedbg;
  this->rotation             = default_config.rotation;
  this->horizontalFlip       = default_config.horizontal_flip;
  this->gammaCorrection      = default_config.gamma_correction;
  this->bitsPerPixel         = default_config.pixel_depth;
  this->histogramNbBins      = default_config.histo_nb_bins;
  this->histogramRangeMin    = default_config.histo_range_min;
  this->histogramRangeMax    = default_config.histo_range_max;

  this->chamberOffsetX      = default_config.chamber_offset_x;
  this->chamberOffsetY      = default_config.chamber_offset_y;

  this->centroidSaturationRegionSide = default_config.centroid_saturation_region_side;
  this->centroidSaturationRegionThreshold = default_config.centroid_saturation_region_threshold;

  //  Read device properties from database.(Automatic code generation)
  //------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AutoROIMagFactorX"));
	dev_prop.push_back(Tango::DbDatum("AutoROIMagFactorY"));
	dev_prop.push_back(Tango::DbDatum("AutoROIMethod"));
	dev_prop.push_back(Tango::DbDatum("AutoStart"));
	dev_prop.push_back(Tango::DbDatum("BitsPerPixel"));
	dev_prop.push_back(Tango::DbDatum("ComputationPeriod"));
	dev_prop.push_back(Tango::DbDatum("Enable2DGaussianFit"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoROI"));
	dev_prop.push_back(Tango::DbDatum("EnableHistogram"));
	dev_prop.push_back(Tango::DbDatum("EnableImageStats"));
	dev_prop.push_back(Tango::DbDatum("EnableProfiles"));
	dev_prop.push_back(Tango::DbDatum("EnableUserROI"));
	dev_prop.push_back(Tango::DbDatum("GammaCorrection"));
	dev_prop.push_back(Tango::DbDatum("HistogramNbBins"));
	dev_prop.push_back(Tango::DbDatum("HistogramRangeMax"));
	dev_prop.push_back(Tango::DbDatum("HistogramRangeMin"));
	dev_prop.push_back(Tango::DbDatum("HorizontalFlip"));
	dev_prop.push_back(Tango::DbDatum("ImageAttributeName"));
	dev_prop.push_back(Tango::DbDatum("ImageCounterAttrName"));
	dev_prop.push_back(Tango::DbDatum("ImageDevice"));
	dev_prop.push_back(Tango::DbDatum("Mode"));
	dev_prop.push_back(Tango::DbDatum("OpticalMagnification"));
	dev_prop.push_back(Tango::DbDatum("PixelSizeX"));
	dev_prop.push_back(Tango::DbDatum("PixelSizeY"));
	dev_prop.push_back(Tango::DbDatum("ProfileFitFixedBg"));
	dev_prop.push_back(Tango::DbDatum("Rotation"));
	dev_prop.push_back(Tango::DbDatum("UserROIOriginX"));
	dev_prop.push_back(Tango::DbDatum("UserROIOriginY"));
	dev_prop.push_back(Tango::DbDatum("UserROIWidth"));
	dev_prop.push_back(Tango::DbDatum("UserROIHeight"));
	dev_prop.push_back(Tango::DbDatum("ChamberOffsetX"));
	dev_prop.push_back(Tango::DbDatum("ChamberOffsetY"));
	dev_prop.push_back(Tango::DbDatum("CentroidSaturationRegionSide"));
	dev_prop.push_back(Tango::DbDatum("CentroidSaturationRegionThreshold"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	ImgBeamAnalyzerClass	*ds_class =
		(static_cast<ImgBeamAnalyzerClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AutoROIMagFactorX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIMagFactorX;
	else {
		//	Try to initialize AutoROIMagFactorX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIMagFactorX;
	}
	//	And try to extract AutoROIMagFactorX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIMagFactorX;

	//	Try to initialize AutoROIMagFactorY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIMagFactorY;
	else {
		//	Try to initialize AutoROIMagFactorY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIMagFactorY;
	}
	//	And try to extract AutoROIMagFactorY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIMagFactorY;

	//	Try to initialize AutoROIMethod from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIMethod;
	else {
		//	Try to initialize AutoROIMethod from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIMethod;
	}
	//	And try to extract AutoROIMethod value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIMethod;

	//	Try to initialize AutoStart from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoStart;
	else {
		//	Try to initialize AutoStart from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoStart;
	}
	//	And try to extract AutoStart value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoStart;

	//	Try to initialize BitsPerPixel from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  bitsPerPixel;
	else {
		//	Try to initialize BitsPerPixel from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  bitsPerPixel;
	}
	//	And try to extract BitsPerPixel value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  bitsPerPixel;

	//	Try to initialize ComputationPeriod from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  computationPeriod;
	else {
		//	Try to initialize ComputationPeriod from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  computationPeriod;
	}
	//	And try to extract ComputationPeriod value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  computationPeriod;

	//	Try to initialize Enable2DGaussianFit from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enable2DGaussianFit;
	else {
		//	Try to initialize Enable2DGaussianFit from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enable2DGaussianFit;
	}
	//	And try to extract Enable2DGaussianFit value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enable2DGaussianFit;

	//	Try to initialize EnableAutoROI from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoROI;
	else {
		//	Try to initialize EnableAutoROI from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableAutoROI;
	}
	//	And try to extract EnableAutoROI value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoROI;

	//	Try to initialize EnableHistogram from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableHistogram;
	else {
		//	Try to initialize EnableHistogram from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableHistogram;
	}
	//	And try to extract EnableHistogram value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableHistogram;

	//	Try to initialize EnableImageStats from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableImageStats;
	else {
		//	Try to initialize EnableImageStats from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableImageStats;
	}
	//	And try to extract EnableImageStats value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableImageStats;

	//	Try to initialize EnableProfiles from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableProfiles;
	else {
		//	Try to initialize EnableProfiles from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableProfiles;
	}
	//	And try to extract EnableProfiles value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProfiles;

	//	Try to initialize EnableUserROI from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableUserROI;
	else {
		//	Try to initialize EnableUserROI from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  enableUserROI;
	}
	//	And try to extract EnableUserROI value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableUserROI;

	//	Try to initialize GammaCorrection from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  gammaCorrection;
	else {
		//	Try to initialize GammaCorrection from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  gammaCorrection;
	}
	//	And try to extract GammaCorrection value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gammaCorrection;

	//	Try to initialize HistogramNbBins from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  histogramNbBins;
	else {
		//	Try to initialize HistogramNbBins from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  histogramNbBins;
	}
	//	And try to extract HistogramNbBins value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  histogramNbBins;

	//	Try to initialize HistogramRangeMax from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  histogramRangeMax;
	else {
		//	Try to initialize HistogramRangeMax from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  histogramRangeMax;
	}
	//	And try to extract HistogramRangeMax value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  histogramRangeMax;

	//	Try to initialize HistogramRangeMin from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  histogramRangeMin;
	else {
		//	Try to initialize HistogramRangeMin from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  histogramRangeMin;
	}
	//	And try to extract HistogramRangeMin value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  histogramRangeMin;

	//	Try to initialize HorizontalFlip from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  horizontalFlip;
	else {
		//	Try to initialize HorizontalFlip from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  horizontalFlip;
	}
	//	And try to extract HorizontalFlip value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  horizontalFlip;

	//	Try to initialize ImageAttributeName from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  imageAttributeName;
	else {
		//	Try to initialize ImageAttributeName from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  imageAttributeName;
	}
	//	And try to extract ImageAttributeName value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  imageAttributeName;

	//	Try to initialize ImageCounterAttrName from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  imageCounterAttrName;
	else {
		//	Try to initialize ImageCounterAttrName from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  imageCounterAttrName;
	}
	//	And try to extract ImageCounterAttrName value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  imageCounterAttrName;

	//	Try to initialize ImageDevice from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  imageDevice;
	else {
		//	Try to initialize ImageDevice from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  imageDevice;
	}
	//	And try to extract ImageDevice value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  imageDevice;

	//	Try to initialize Mode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  mode;
	else {
		//	Try to initialize Mode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  mode;
	}
	//	And try to extract Mode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mode;

	//	Try to initialize OpticalMagnification from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  opticalMagnification;
	else {
		//	Try to initialize OpticalMagnification from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  opticalMagnification;
	}
	//	And try to extract OpticalMagnification value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  opticalMagnification;

	//	Try to initialize PixelSizeX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pixelSizeX;
	else {
		//	Try to initialize PixelSizeX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pixelSizeX;
	}
	//	And try to extract PixelSizeX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pixelSizeX;

	//	Try to initialize PixelSizeY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pixelSizeY;
	else {
		//	Try to initialize PixelSizeY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pixelSizeY;
	}
	//	And try to extract PixelSizeY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pixelSizeY;

	//	Try to initialize ProfileFitFixedBg from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  profileFitFixedBg;
	else {
		//	Try to initialize ProfileFitFixedBg from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  profileFitFixedBg;
	}
	//	And try to extract ProfileFitFixedBg value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  profileFitFixedBg;

	//	Try to initialize Rotation from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  rotation;
	else {
		//	Try to initialize Rotation from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  rotation;
	}
	//	And try to extract Rotation value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rotation;

	//	Try to initialize UserROIOriginX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  userROIOriginX;
	else {
		//	Try to initialize UserROIOriginX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  userROIOriginX;
	}
	//	And try to extract UserROIOriginX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  userROIOriginX;

	//	Try to initialize UserROIOriginY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  userROIOriginY;
	else {
		//	Try to initialize UserROIOriginY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  userROIOriginY;
	}
	//	And try to extract UserROIOriginY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  userROIOriginY;

	//	Try to initialize UserROIWidth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  userROIWidth;
	else {
		//	Try to initialize UserROIWidth from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  userROIWidth;
	}
	//	And try to extract UserROIWidth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  userROIWidth;

	//	Try to initialize UserROIHeight from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  userROIHeight;
	else {
		//	Try to initialize UserROIHeight from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  userROIHeight;
	}
	//	And try to extract UserROIHeight value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  userROIHeight;

	//	Try to initialize ChamberOffsetX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  chamberOffsetX;
	else {
		//	Try to initialize ChamberOffsetX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  chamberOffsetX;
	}
	//	And try to extract ChamberOffsetX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  chamberOffsetX;

	//	Try to initialize ChamberOffsetY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  chamberOffsetY;
	else {
		//	Try to initialize ChamberOffsetY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  chamberOffsetY;
	}
	//	And try to extract ChamberOffsetY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  chamberOffsetY;

	//	Try to initialize CentroidSaturationRegionSide from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  centroidSaturationRegionSide;
	else {
		//	Try to initialize CentroidSaturationRegionSide from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  centroidSaturationRegionSide;
	}
	//	And try to extract CentroidSaturationRegionSide value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centroidSaturationRegionSide;

	//	Try to initialize CentroidSaturationRegionThreshold from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  centroidSaturationRegionThreshold;
	else {
		//	Try to initialize CentroidSaturationRegionThreshold from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  centroidSaturationRegionThreshold;
	}
	//	And try to extract CentroidSaturationRegionThreshold value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centroidSaturationRegionThreshold;

  //  End of Automatic code generation
  //------------------------------------------------------------------

  std::transform(mode.begin(), mode.end(), mode.begin(), ::tolower);
  if (mode == "unspecified")
  {
    ERROR_STREAM << "required device property <Mode> is missing" << endl;
    this->critical_property_missing_ = true;
  }

  std::transform(this->autoROIMethod.begin(), this->autoROIMethod.end(), this->autoROIMethod.begin(), ::tolower);
  if (this->autoROIMethod == "unspecified")
  {
    ERROR_STREAM << "required device property <AutoROIMethod> is missing" << endl;
    this->critical_property_missing_ = true;
  }

  //- Build the initial configuration
  //------------------------------------------------------------------
  this->current_config_ = BIAConfig(); //- set all members to their default value

  this->current_config_.enable_image_stats      = enableImageStats;
  this->current_config_.enable_profile          = enableProfiles;
  this->current_config_.enable_histogram        = enableHistogram;
  this->current_config_.enable_2d_gaussian_fit  = enable2DGaussianFit;
  this->current_config_.enable_auto_roi         = enableAutoROI;
  this->current_config_.enable_user_roi         = enableUserROI;
  this->current_config_.comput_period           = computationPeriod;
  this->current_config_.pixel_size_x            = pixelSizeX;
  this->current_config_.pixel_size_y            = pixelSizeY;
  this->current_config_.optical_mag             = opticalMagnification;
  this->current_config_.user_roi_origin_x    = userROIOriginX;
  this->current_config_.user_roi_origin_y    = userROIOriginY;
  this->current_config_.user_roi_width      = userROIWidth;
  this->current_config_.user_roi_height      = userROIHeight;
  this->current_config_.profilefit_fixedbg      = profileFitFixedBg;
  this->current_config_.auto_roi_method         = (autoROIMethod == "threshold" ? BIAConfig::AUTOROI_THRESHOLD : BIAConfig::AUTOROI_PROFILES);
  this->current_config_.auto_roi_mag_factor_x   = autoROIMagFactorX;
  this->current_config_.auto_roi_mag_factor_y   = autoROIMagFactorY;
  this->current_config_.rotation                = rotation;
  this->current_config_.horizontal_flip         = horizontalFlip;
  this->current_config_.gamma_correction        = gammaCorrection;
  this->current_config_.pixel_depth             = bitsPerPixel;
  this->current_config_.histo_nb_bins           = histogramNbBins;
  this->current_config_.histo_range_min         = histogramRangeMin;
  this->current_config_.histo_range_max         = histogramRangeMax;

  this->current_config_.chamber_offset_x       = chamberOffsetX;
  this->current_config_.chamber_offset_y       = chamberOffsetY;

  this->current_config_.centroid_saturation_region_side = centroidSaturationRegionSide;
  this->current_config_.centroid_saturation_region_threshold = centroidSaturationRegionThreshold;

  //- leave the other members to their default values
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::always_executed_hook()
// 
// description :   method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::always_executed_hook()
{
  this->update_state();
}

void ImgBeamAnalyzer::CleanAvailableList(unsigned int nbLeft/* = 0*/)
{
  LOCK_AD

  if (m_AvailableDataList.size() > nbLeft)
  {
	  while (m_AvailableDataList.size() > nbLeft)
	  {
		  BIAData* pNoLongerUsed = m_AvailableDataList.back();
#ifdef OUTPUT_DEBUG
      // ----------------------------------------------------------------------
      Tango::DevUShort* p = pNoLongerUsed->roi_image.base();
      char Res[200];
      if (pNoLongerUsed->reference_count() > 1)
        sprintf(Res, "CleanAvailableList : Release this data (Data Start Address = %p, ROIImage Address=%p, Ref count before release=%d)\r\n", 
                      &(pNoLongerUsed->config), p, pNoLongerUsed->reference_count());
      else
        sprintf(Res, "CleanAvailableList : This data (Data Start Address = %p, ROIImage Address=%p) was DESTROYED !\r\n", 
                      &(pNoLongerUsed->config), p);
      OutputDebugString(Res);
      // ----------------------------------------------------------------------
#endif  //OUTPUT_DEBUG
		  pNoLongerUsed->release();
      m_AvailableDataList.pop_back();
	  }
  }

  UNLOCK_AD
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_attr_hardware
// 
// description :   Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_attr_hardware(vector<long> &attr_list)
{
  //  Add your own code here
  ENTER_FUNC

#ifdef OUTPUT_DEBUG
  // ----------------------------------------------------------------------
	bool IsROIImage = false;
	for (unsigned int i = 0;i < attr_list.size();i++)
	{	
		if (dev_attr->get_attr_by_ind(attr_list[i]).get_name() == "ROIImage")
		{
			IsROIImage = true;
			break;
		}
	}
  char Res[512];
  if (IsROIImage)
  {
    sprintf(Res, "IN>>read_attr_hardware ROIImage(Nb ROIImage in list=%d)\r\n", m_AvailableDataList.size());
    OutputDebugString(Res);
  }
  // ------------------------------------------------------------------------
#endif //OUTPUT_DEBUG

  try
  {
    //---- READ DATA ---------------------------------------------------------------------
    //- release any unused existing data
    CleanAvailableList(10 /* leave the last 10 available data read to give time for Tango
                         Client devices to read available data without any memory release 
                         in concurent thread risk when we don't use the mutex method
                         is Tango::Attribute::set_value */);

    //- read data
    //- if not available, return value will be 0
    //- we DON'T put the device in a FAULT state if data is not available
    //- but we update the status...
    BIAData* pLastProcessed;
    this->task_->get_data (pLastProcessed);

    LOCK_AD

    BIAData* pLastAvailableData = NULL;
    if (m_AvailableDataList.size() > 0)
      pLastAvailableData = m_AvailableDataList.front();
    if (pLastProcessed != NULL && pLastProcessed->roi_image.base() != NULL &&       // An image was processed AND
          (pLastAvailableData == NULL ||                                            // No image available yet OR
          pLastAvailableData->roi_image.base() != pLastProcessed->roi_image.base()))// Last available image is not the same
    {
        m_AvailableDataList.push_front(pLastProcessed);
#ifdef OUTPUT_DEBUG
      // ----------------------------------------------------------------------
      char Res[200];
      Tango::DevUShort* p = pLastProcessed->roi_image.base();
      sprintf(Res, "read_attr_hardware ROIImage : A new Data was processed (Data Start Address = %p, ROIImage Address=%p) \r\n", 
                    &(pLastProcessed->config), p);
      OutputDebugString(Res);
      // ----------------------------------------------------------------------
#endif  //OUTPUT_DEBUG
    }

    UNLOCK_AD
  }
  catch(...)
  {
    UNLOCK_AD

    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "An unknown error occured",
                    "ImgBeamAnalyzer::read_attr_hardware()");
  }

  //- the state/status may be updated by the call to this->task_->get_data()
  this->update_state();

}
//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_RmsX
// 
// description :   Extract real attribute values for RmsX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_RmsX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(rms_x, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_RmsY
// 
// description :   Extract real attribute values for RmsY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_RmsY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(rms_y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileHelperImg
// 
// description :   Extract real attribute values for LineProfileHelperImg acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileHelperImg(Tango::Attribute &attr)
{
  READ_OUTPUT_IMAGE_ATTR(line_profile_helper_img, enable_profile, Tango::DevFloat);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileOriginX
// 
// description :   Extract real attribute values for LineProfileOriginX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileOriginX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profile_origin_x, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_LineProfileOriginX
// 
// description :   Write LineProfileOriginX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_LineProfileOriginX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( profile_origin_x, Tango::DevLong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileOriginY
// 
// description :   Extract real attribute values for LineProfileOriginY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileOriginY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profile_origin_y, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_LineProfileOriginY
// 
// description :   Write LineProfileOriginY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_LineProfileOriginY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( profile_origin_y, Tango::DevLong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileEndX
// 
// description :   Extract real attribute values for LineProfileEndX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileEndX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profile_end_x, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_LineProfileEndX
// 
// description :   Write LineProfileEndX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_LineProfileEndX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( profile_end_x, Tango::DevLong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileEndY
// 
// description :   Extract real attribute values for LineProfileEndY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileEndY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profile_end_y, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_LineProfileEndY
// 
// description :   Write LineProfileEndY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_LineProfileEndY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( profile_end_y, Tango::DevLong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileThickness
// 
// description :   Extract real attribute values for LineProfileThickness acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileThickness(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profile_thickness, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_LineProfileThickness
// 
// description :   Write LineProfileThickness attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_LineProfileThickness(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( profile_thickness, Tango::DevLong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberOffsetX
// 
// description :   Extract real attribute values for ChamberOffsetX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberOffsetX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(chamber_offset_x, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_ChamberOffsetX
// 
// description :   Write ChamberOffsetX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_ChamberOffsetX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( chamber_offset_x, Tango::DevDouble );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberOffsetY
// 
// description :   Extract real attribute values for ChamberOffsetY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberOffsetY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(chamber_offset_y, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_ChamberOffsetY
// 
// description :   Write ChamberOffsetY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_ChamberOffsetY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR( chamber_offset_y, Tango::DevDouble );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberCentroidX
// 
// description :   Extract real attribute values for ChamberCentroidX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberCentroidX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(chamber_centroid_x, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberCentroidY
// 
// description :   Extract real attribute values for ChamberCentroidY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberCentroidY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(chamber_centroid_y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberXProjFitCenter
// 
// description :   Extract real attribute values for ChamberXProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberXProjFitCenter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(chamber_xproj_center, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ChamberYProjFitCenter
// 
// description :   Extract real attribute values for ChamberYProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ChamberYProjFitCenter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(chamber_yproj_center, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitNbIter
// 
// description :   Extract real attribute values for LineProfileFitNbIter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitNbIter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_nb_iter, enable_profile, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitRelChange
// 
// description :   Extract real attribute values for LineProfileFitRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitRelChange(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_eps, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitBG
// 
// description :   Extract real attribute values for LineProfileFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitBG(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_bg, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitConverged
// 
// description :   Extract real attribute values for LineProfileFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitConverged(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_fit_converged, enable_profile, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitCenter
// 
// description :   Extract real attribute values for LineProfileFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitCenter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_center, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitMag
// 
// description :   Extract real attribute values for LineProfileFitMag acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitMag(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_mag, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitSigma
// 
// description :   Extract real attribute values for LineProfileFitSigma acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitSigma(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_sigma, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitFWHM
// 
// description :   Extract real attribute values for LineProfileFitFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitFWHM(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_fwhm, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitChi2
// 
// description :   Extract real attribute values for LineProfileFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitChi2(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(line_profile_chi2, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfile
// 
// description :   Extract real attribute values for LineProfile acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfile(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(line_profile, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileFitted
// 
// description :   Extract real attribute values for LineProfileFitted acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileFitted(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(line_profile_fitted, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_LineProfileError
// 
// description :   Extract real attribute values for LineProfileError acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_LineProfileError(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(line_profile_error, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProj
// 
// description :   Extract real attribute values for XProj acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProj(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(xproj, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitted
// 
// description :   Extract real attribute values for XProjFitted acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitted(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(xproj_fitted, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjError
// 
// description :   Extract real attribute values for XProjError acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjError(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(xproj_error, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProj
// 
// description :   Extract real attribute values for YProj acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProj(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(yproj, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitted
// 
// description :   Extract real attribute values for YProjFitted acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitted(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(yproj_fitted, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjError
// 
// description :   Extract real attribute values for YProjError acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjError(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(yproj_error, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_BgSubstraction
// 
// description :   Extract real attribute values for BgSubstraction acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_BgSubstraction(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(bg_substraction, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_BgSubstraction
// 
// description :   Write BgSubstraction attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_BgSubstraction(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(bg_substraction, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitConverged
// 
// description :   Extract real attribute values for XProjFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitConverged(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_fit_converged, enable_profile, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitCenter
// 
// description :   Extract real attribute values for XProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitCenter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_center, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitMag
// 
// description :   Extract real attribute values for XProjFitMag acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitMag(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_mag, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitSigma
// 
// description :   Extract real attribute values for XProjFitSigma acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitSigma(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_sigma, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitFWHM
// 
// description :   Extract real attribute values for XProjFitFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitFWHM(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_fwhm, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitBG
// 
// description :   Extract real attribute values for XProjFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitBG(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_bg, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitChi2
// 
// description :   Extract real attribute values for XProjFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitChi2(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_chi2, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitConverged
// 
// description :   Extract real attribute values for YProjFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitConverged(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_fit_converged, enable_profile, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitCenter
// 
// description :   Extract real attribute values for YProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitCenter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_center, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitMag
// 
// description :   Extract real attribute values for YProjFitMag acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitMag(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_mag, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitSigma
// 
// description :   Extract real attribute values for YProjFitSigma acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitSigma(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_sigma, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitFWHM
// 
// description :   Extract real attribute values for YProjFitFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitFWHM(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_fwhm, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitBG
// 
// description :   Extract real attribute values for YProjFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitBG(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_bg, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitChi2
// 
// description :   Extract real attribute values for YProjFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitChi2(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_chi2, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitNbIter
// 
// description :   Extract real attribute values for XProjFitNbIter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitNbIter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_nb_iter, enable_profile, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_XProjFitRelChange
// 
// description :   Extract real attribute values for XProjFitRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_XProjFitRelChange(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(xproj_eps, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitNbIter
// 
// description :   Extract real attribute values for YProjFitNbIter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitNbIter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_nb_iter, enable_profile, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_YProjFitRelChange
// 
// description :   Extract real attribute values for YProjFitRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_YProjFitRelChange(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(yproj_eps, enable_profile, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIThreshold
// 
// description :   Extract real attribute values for AutoROIThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIThreshold(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(auto_roi_threshold, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_AutoROIThreshold
// 
// description :   Write AutoROIThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_AutoROIThreshold(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(auto_roi_threshold, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ProfileFitFixedBg
// 
// description :   Extract real attribute values for ProfileFitFixedBg acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ProfileFitFixedBg(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(profilefit_fixedbg, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_ProfileFitFixedBg
// 
// description :   Write ProfileFitFixedBg attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_ProfileFitFixedBg(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(profilefit_fixedbg, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIMagFactorX
// 
// description :   Extract real attribute values for AutoROIMagFactorX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIMagFactorX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(auto_roi_mag_factor_x, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_AutoROIMagFactorX
// 
// description :   Write AutoROIMagFactorX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_AutoROIMagFactorX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(auto_roi_mag_factor_x, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIMagFactorY
// 
// description :   Extract real attribute values for AutoROIMagFactorY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIMagFactorY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(auto_roi_mag_factor_y, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_AutoROIMagFactorY
// 
// description :   Write AutoROIMagFactorY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_AutoROIMagFactorY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(auto_roi_mag_factor_y, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_HistogramRangeMin
// 
// description :   Extract real attribute values for HistogramRangeMin acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_HistogramRangeMin(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(histo_range_min, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_HistogramRangeMin
// 
// description :   Write HistogramRangeMin attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_HistogramRangeMin(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(histo_range_min, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_HistogramRangeMax
// 
// description :   Extract real attribute values for HistogramRangeMax acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_HistogramRangeMax(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(histo_range_max, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_HistogramRangeMax
// 
// description :   Write HistogramRangeMax attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_HistogramRangeMax(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(histo_range_max, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EnableHistogram
// 
// description :   Extract real attribute values for EnableHistogram acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EnableHistogram(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_histogram, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_EnableHistogram
// 
// description :   Write EnableHistogram attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_EnableHistogram(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_histogram, Tango::DevBoolean);
}


//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_HistogramNbBins
// 
// description :   Extract real attribute values for HistogramNbBins acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_HistogramNbBins(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(histo_nb_bins, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_HistogramNbBins
// 
// description :   Write HistogramNbBins attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_HistogramNbBins(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(histo_nb_bins, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Histogram
// 
// description :   Extract real attribute values for Histogram acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Histogram(Tango::Attribute &attr)
{
  READ_OUTPUT_SPECTRUM_ATTR(histogram, enable_histogram, Tango::DevFloat);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitNbIter
// 
// description :   Extract real attribute values for GaussianFitNbIter acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitNbIter(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_nb_iter, enable_2d_gaussian_fit, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitRelChange
// 
// description :   Extract real attribute values for GaussianFitRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitRelChange(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_eps, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIFound
// 
// description :   Extract real attribute values for AutoROIFound acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIFound(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(auto_roi_found, enable_auto_roi, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitConverged
// 
// description :   Extract real attribute values for GaussianFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitConverged(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_converged, enable_2d_gaussian_fit, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_OpticalMagnification
// 
// description :   Extract real attribute values for OpticalMagnification acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_OpticalMagnification(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(optical_mag, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_OpticalMagnification
// 
// description :   Write OpticalMagnification attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_OpticalMagnification(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(optical_mag, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_PixelSizeX
// 
// description :   Extract real attribute values for PixelSizeX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_PixelSizeX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(pixel_size_x, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_PixelSizeX
// 
// description :   Write PixelSizeX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_PixelSizeX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(pixel_size_x, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_PixelSizeY
// 
// description :   Extract real attribute values for PixelSizeY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_PixelSizeY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(pixel_size_y, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_PixelSizeY
// 
// description :   Write PixelSizeY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_PixelSizeY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(pixel_size_y, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_BitsPerPixel
// 
// description :   Extract real attribute values for BitsPerPixel acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_BitsPerPixel(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(pixel_depth, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_BitsPerPixel
// 
// description :   Write BitsPerPixel attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_BitsPerPixel(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(pixel_depth, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GammaCorrection
// 
// description :   Extract real attribute values for GammaCorrection acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GammaCorrection(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(gamma_correction, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_GammaCorrection
// 
// description :   Write GammaCorrection attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_GammaCorrection(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(gamma_correction, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Rotation
// 
// description :   Extract real attribute values for Rotation acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Rotation(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(rotation, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Rotation
// 
// description :   Write Rotation attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Rotation(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(rotation, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_HorizontalFlip
// 
// description :   Extract real attribute values for HorizontalFlip acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_HorizontalFlip(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(horizontal_flip, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_HorizontalFlip
// 
// description :   Write HorizontalFlip attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_HorizontalFlip(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(horizontal_flip, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitMajorAxisFWHM
// 
// description :   Extract real attribute values for GaussianFitMajorAxisFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitMajorAxisFWHM(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_major_axis_fwhm, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitMinorAxisFWHM
// 
// description :   Extract real attribute values for GaussianFitMinorAxisFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitMinorAxisFWHM(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_minor_axis_fwhm, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_UserROIOriginX
// 
// description :   Write UserROIOriginX attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_UserROIOriginX(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(user_roi_origin_x, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_UserROIOriginY
// 
// description :   Write UserROIOriginY attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_UserROIOriginY(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(user_roi_origin_y, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_UserROIWidth
// 
// description :   Write UserROIWidth attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_UserROIWidth(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(user_roi_width, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_UserROIHeight
// 
// description :   Write UserROIHeight attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_UserROIHeight(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(user_roi_height, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EnableUserROI
// 
// description :   Extract real attribute values for EnableUserROI acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EnableUserROI(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_user_roi, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_EnableUserROI
// 
// description :   Write EnableUserROI attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_EnableUserROI(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_user_roi, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_UserROIOriginX
// 
// description :   Extract real attribute values for UserROIOriginX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_UserROIOriginX(Tango::Attribute &attr)
{
  READ_INPUT_ATTR_WITH_ALARM(user_roi_origin_x, user_roi_alarm, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_UserROIOriginY
// 
// description :   Extract real attribute values for UserROIOriginY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_UserROIOriginY(Tango::Attribute &attr)
{
  READ_INPUT_ATTR_WITH_ALARM(user_roi_origin_y, user_roi_alarm, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_UserROIWidth
// 
// description :   Extract real attribute values for UserROIWidth acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_UserROIWidth(Tango::Attribute &attr)
{
  READ_INPUT_ATTR_WITH_ALARM(user_roi_width, user_roi_alarm, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_UserROIHeight
// 
// description :   Extract real attribute values for UserROIHeight acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_UserROIHeight(Tango::Attribute &attr)
{
  READ_INPUT_ATTR_WITH_ALARM(user_roi_height, user_roi_alarm, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIOriginX
// 
// description :   Extract real attribute values for AutoROIOriginX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIOriginX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(auto_roi_origin_x, enable_auto_roi, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIOriginY
// 
// description :   Extract real attribute values for AutoROIOriginY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIOriginY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(auto_roi_origin_y, enable_auto_roi, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIWidth
// 
// description :   Extract real attribute values for AutoROIWidth acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIWidth(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(auto_roi_width, enable_auto_roi, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AutoROIHeight
// 
// description :   Extract real attribute values for AutoROIHeight acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AutoROIHeight(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(auto_roi_height, enable_auto_roi, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ROIImage
// 
// description :   Extract real attribute values for ROIImage acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ROIImage(Tango::Attribute &attr)
{
	// Mantis bug 14571 : enable 32 bit data
  READ_OUTPUT_IMAGE_ATTR_ALWAYSACTIV(roi_image, Tango::DevULong);  // JCP
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EnableAutoROI
// 
// description :   Extract real attribute values for EnableAutoROI acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EnableAutoROI(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_auto_roi, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_EnableAutoROI
// 
// description :   Write EnableAutoROI attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_EnableAutoROI(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_auto_roi, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_MaxIntensity
// 
// description :   Extract real attribute values for MaxIntensity acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_MaxIntensity(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(max_intensity, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CentroidX
// 
// description :   Extract real attribute values for CentroidX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CentroidX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(centroid_x, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CentroidY
// 
// description :   Extract real attribute values for CentroidY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CentroidY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(centroid_y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CentroidSaturated
// 
// description :   Extract real attribute values for CentroidSaturated acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CentroidSaturated(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(centroid_saturated, enable_image_stats, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CentroidSaturationRegionSide
//
// description :   Extract real attribute values for CentroidSaturationRegionSide acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CentroidSaturationRegionSide(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(centroid_saturation_region_side, Tango::DevLong);
}
//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CentroidSaturationRegionThreshold
//
// description :   Extract real attribute values for CentroidSaturationRegionThreshold acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CentroidSaturationRegionThreshold(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(centroid_saturation_region_threshold, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_CentroidSaturationRegionSide
//
// description :   Write CentroidSaturationRegionSide attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_CentroidSaturationRegionSide(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(centroid_saturation_region_side, Tango::DevLong );
}
//+----------------------------------------------------------------------------
// method :     ImgBeamAnalyzer::write_CentroidSaturationRegionThreshold
//
// description :   Write CentroidSaturationRegionThreshold attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_CentroidSaturationRegionThreshold(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(centroid_saturation_region_threshold, Tango::DevLong );
}
//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_VarianceX
// 
// description :   Extract real attribute values for VarianceX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_VarianceX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(variance_x, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_VarianceY
// 
// description :   Extract real attribute values for VarianceY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_VarianceY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(variance_y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CovarianceXY
// 
// description :   Extract real attribute values for CovarianceXY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CovarianceXY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(covariance_xy, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_CorrelationXY
// 
// description :   Extract real attribute values for CorrelationXY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_CorrelationXY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(correlation_xy, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_SkewX
// 
// description :   Extract real attribute values for SkewX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_SkewX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(skew_x, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_SkewY
// 
// description :   Extract real attribute values for SkewY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_SkewY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(skew_y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_SkewX2Y
// 
// description :   Extract real attribute values for SkewX2Y acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_SkewX2Y(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(skew_x2y, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_SkewXY2
// 
// description :   Extract real attribute values for SkewXY2 acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_SkewXY2(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(skew_xy2, enable_image_stats, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitCenterX
// 
// description :   Extract real attribute values for GaussianFitCenterX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitCenterX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_centroid_x, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitCenterY
// 
// description :   Extract real attribute values for GaussianFitCenterY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitCenterY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_centroid_y, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitVarianceX
// 
// description :   Extract real attribute values for GaussianFitVarianceX acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitVarianceX(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_variance_x, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitVarianceY
// 
// description :   Extract real attribute values for GaussianFitVarianceY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitVarianceY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_variance_y, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitCovarianceXY
// 
// description :   Extract real attribute values for GaussianFitCovarianceXY acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitCovarianceXY(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_covariance_xy, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_InputImage
// 
// description :   Write InputImage attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_InputImage(Tango::WAttribute &attr)
{
  //FIXME: SBlanch: I never use it, but does this macro work?
  //                From the first commit never changed, but.
  READ_OUTPUT_IMAGE_ATTR_ALWAYSACTIV( input_image, Tango::DevULong );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitBG
// 
// description :   Extract real attribute values for GaussianFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitBG(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_bg, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_AlarmZone
// 
// description :   Extract real attribute values for AlarmZone acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_AlarmZone(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(alarm_zone, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_AlarmZone
// 
// description :   Write AlarmZone attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_AlarmZone(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(alarm_zone, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Fit2DNbIterMax
// 
// description :   Extract real attribute values for Fit2DNbIterMax acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Fit2DNbIterMax(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(fit2d_nb_iter, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Fit2DNbIterMax
// 
// description :   Write Fit2DNbIterMax attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Fit2DNbIterMax(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(fit2d_nb_iter, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Fit2DMaxRelChange
// 
// description :   Extract real attribute values for Fit2DMaxRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Fit2DMaxRelChange(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(fit2d_max_rel_change, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Fit2DMaxRelChange
// 
// description :   Write Fit2DMaxRelChange attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Fit2DMaxRelChange(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(fit2d_max_rel_change, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Fit1DNbIterMax
// 
// description :   Extract real attribute values for Fit1DNbIterMax acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Fit1DNbIterMax(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(fit1d_nb_iter, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Fit1DNbIterMax
// 
// description :   Write Fit1DNbIterMax attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Fit1DNbIterMax(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(fit1d_nb_iter, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Fit1DMaxRelChange
// 
// description :   Extract real attribute values for Fit1DMaxRelChange acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Fit1DMaxRelChange(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(fit1d_max_rel_change, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Fit1DMaxRelChange
// 
// description :   Write Fit1DMaxRelChange attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Fit1DMaxRelChange(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(fit1d_max_rel_change, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitChi2
// 
// description :   Extract real attribute values for GaussianFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitChi2(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_chi2, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitParameterCovariance
// 
// description :   Extract real attribute values for GaussianFitParameterCovariance acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitParameterCovariance(Tango::Attribute &attr)
{
  READ_OUTPUT_IMAGE_ATTR( gaussfit_parameters_covariance, enable_2d_gaussian_fit, Tango::DevDouble );
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitMagnitude
// 
// description :   Extract real attribute values for GaussianFitMagnitude acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitMagnitude(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_magnitude, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_GaussianFitTilt
// 
// description :   Extract real attribute values for GaussianFitTilt acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_GaussianFitTilt(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(gaussfit_tilt, enable_2d_gaussian_fit, Tango::DevDouble);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_Enable2DGaussianFit
// 
// description :   Extract real attribute values for Enable2DGaussianFit acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_Enable2DGaussianFit(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_2d_gaussian_fit, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_Enable2DGaussianFit
// 
// description :   Write Enable2DGaussianFit attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_Enable2DGaussianFit(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_2d_gaussian_fit, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ComputationPeriod
// 
// description :   Extract real attribute values for ComputationPeriod acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ComputationPeriod(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(comput_period, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_ComputationPeriod
// 
// description :   Write ComputationPeriod attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_ComputationPeriod(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(comput_period, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EstimComputTime
// 
// description :   Extract real attribute values for EstimComputTime acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EstimComputTime(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR_ALWAYSACTIV(estim_comput_time, Tango::DevLong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EnableImageStats
// 
// description :   Extract real attribute values for EnableImageStats acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EnableImageStats(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_image_stats, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_EnableImageStats
// 
// description :   Write EnableImageStats attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_EnableImageStats(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_image_stats, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_EnableProfiles
// 
// description :   Extract real attribute values for EnableProfiles acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_EnableProfiles(Tango::Attribute &attr)
{
  READ_INPUT_ATTR(enable_profile, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::write_EnableProfiles
// 
// description :   Write EnableProfiles attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::write_EnableProfiles(Tango::WAttribute &attr)
{
  WRITE_INPUT_ATTR(enable_profile, Tango::DevBoolean);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_InputImage
// 
// description :   Extract real attribute values for InputImage acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_InputImage(Tango::Attribute &attr)
{
  // Mantis bug 14571 : enable 32 bit data
  READ_OUTPUT_IMAGE_ATTR_ALWAYSACTIV(input_image, Tango::DevULong);
}

//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_MeanIntensity
// 
// description :   Extract real attribute values for MeanIntensity acquisition result.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_MeanIntensity(Tango::Attribute &attr)
{
  READ_OUTPUT_SCALAR_ATTR(mean_intensity, enable_image_stats, Tango::DevDouble);
}


//+----------------------------------------------------------------------------
//
// method :     ImgBeamAnalyzer::read_ImageCounter
// 
// description :   Extract real attribute values for ImageCounter
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzer::read_ImageCounter(Tango::Attribute &attr)
{
  attr.set_value(&this->image_counter_);
}

//+------------------------------------------------------------------
/**
 *	method:	ImgBeamAnalyzer::start
 *
 *	description:	method to execute "Start"
 *
 *
 */
//+------------------------------------------------------------------
void ImgBeamAnalyzer::start()
{
  if (this->device_mode_ == MODE_ONESHOT)
  {
    THROW_DEVFAILED("OPERATION_NOT_ALLOWED",
                    "In ONESHOT mode, the 'Start' command is disabled",
                    "ImgBeamAnalyzer::start()");
  }

  if (this->properly_initialized_)
  {
    try
    {
      if (this->device_mode_ == MODE_EVENT) {
        if (this->image_source_ && ! this->image_source_->observer_registered())
            this->image_source_->register_observer(this);
      } else
        this->task_->start(kCOMMAND_TIMEOUT);
    }
    catch( yat::Exception& ex )
    {
      yat4tango::YATDevFailed df(ex);
      RETHROW_DEVFAILED(df,
                        "SOFTWARE_FAILURE",
                        "Error while trying to START",
                        "ImgBeamAnalyzer::start()");
    }
    catch(...)
    {
      THROW_DEVFAILED("UNKNWON_ERROR",
                      "Unknown error while trying to START",
                      "ImgBeamAnalyzer::start()");
    }
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgBeamAnalyzer::stop
 *
 *	description:	method to execute "Stop"
 *
 *
 */
//+------------------------------------------------------------------
void ImgBeamAnalyzer::stop()
{
  if (this->device_mode_ == MODE_ONESHOT)
  {
    THROW_DEVFAILED("OPERATION_NOT_ALLOWED",
                    "In ONESHOT mode, the 'Stop' command is disabled",
                    "ImgBeamAnalyzer::stop()");
  }

  if (this->properly_initialized_)
  {
    try
    {
      if (this->image_source_ && this->device_mode_ == MODE_EVENT)
        this->image_source_->register_observer(0);       
      else
        this->task_->stop(kCOMMAND_TIMEOUT);
    }
    catch( yat::Exception& ex )
    {
      yat4tango::YATDevFailed df(ex);
      RETHROW_DEVFAILED(df,
                        "SOFTWARE_FAILURE",
                        "Error while trying to STOP",
                        "ImgBeamAnalyzer::stop()");
    }
    catch(...)
    {
      THROW_DEVFAILED("UNKNWON_ERROR",
                      "Unknown error while trying to STOP",
                      "ImgBeamAnalyzer::stop()");
    }
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgBeamAnalyzer::process
 *
 *	description:	method to execute "Process"
 *
 *
 */
//+------------------------------------------------------------------
void ImgBeamAnalyzer::process()
{
  if (this->process_command_allowed_ == false)
  {
    THROW_DEVFAILED("OPERATION_NOT_ALLOWED",
                    "Device mode must be ONESHOT (configured in a device property) to use the 'Process' command",
                    "ImgBeamAnalyzer::process");
  }

  //- retrieve the image from the remote device
  ImageAndInfo imginf;
  try
  {
    if (! this->image_source_) {
      THROW_DEVFAILED("UNDEFINED__IMAGE_SOURCE",
                      "No valid image source. Check the device configuration",
                      "ImgBeamAnalyzer::process");
    }
    this->image_source_->get_image(imginf);
  }
  catch (yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    RETHROW_DEVFAILED(df,
                      "SOFTWARE_FAILURE",
                      "Unable to get image from remote device",
                      "ImgBeamAnalyzer::process");
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unable to get image from remote device",
                    "ImgBeamAnalyzer::process");
  }

  try
  {
    this->process_command_waiting_ = true;
    this->task_->process( imginf, true, kCOMMAND_TIMEOUT );
    this->process_command_waiting_ = false;
  }
  catch (yat::Exception& ex)
  {
    this->process_command_waiting_ = false;
    yat4tango::YATDevFailed df(ex);
    RETHROW_DEVFAILED(df,
                      "SOFTWARE_FAILURE",
                      "Processing has failed",
                      "ImgBeamAnalyzer::process");
  }
  catch(...)
  {
    this->process_command_waiting_ = false;
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Processing has failed",
                    "ImgBeamAnalyzer::process");
  }

  if (this->device_mode_ == MODE_EVENT)
    this->push_change_event("ImageCounter", &this->image_counter_);
}

void ImgBeamAnalyzer::just_process(ImageAndInfo & imginf) throw (yat::Exception)
{
  if (this->device_mode_ != MODE_EVENT)
    return;

  if (! imginf.image)
  {
    THROW_YAT_ERROR("NO_DATA",
                    "no valid image to process",
                    "ImgBeamAnalyzer::just_process");
  }

  try
  {
    this->task_->process( imginf, false, kCOMMAND_TIMEOUT );
  }
  catch(...)
  {
    THROW_YAT_ERROR("UNKNOWN_ERROR",
                    "Processing has failed",
                    "ImgBeamAnalyzer::just_process");
  }
}

void ImgBeamAnalyzer::on_image_processed(BIAData* data)
{
  try {
    this->image_counter_ += 1;
    // If someone executes the 'Process' here we will end with:
    //  - Process command waiting for the worker thread to finish
    //    while holding the tango mutex.
    //  - push_change_event executed in the worker, needs the
    //    tango mutex!
    //  - DEADLOCK_AVAILABLE_LIST!
    if (!this->process_command_waiting_ && this->device_mode_ == MODE_EVENT)
        this->push_change_event("ImageCounter", &this->image_counter_);
  } catch(...) {
    return; // just ignore any problems with this...
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgBeamAnalyzer::save_current_settings
 *
 *	description:	method to execute "SaveCurrentSettings"
 *
 *
 */
//+------------------------------------------------------------------
void ImgBeamAnalyzer::save_current_settings()
{
  DEBUG_STREAM << "ImgBeamAnalyzer::save_current_settings(): entering... !" << endl;

  //  Add your own code to control device here
  Tango::DbData  data;

# define ADD_DATUM( name, config_member ) \
  { \
    Tango::DbDatum datum( #name ); \
    datum << config_member; \
    data.push_back(datum); \
  }

  ADD_DATUM( AutoROIMagFactorX,     this->current_config_.auto_roi_mag_factor_x );
  ADD_DATUM( AutoROIMagFactorY,     this->current_config_.auto_roi_mag_factor_y );
  ADD_DATUM( ComputationPeriod,     static_cast<long>(this->current_config_.comput_period ));
  ADD_DATUM( Enable2DGaussianFit,   this->current_config_.enable_2d_gaussian_fit );
  ADD_DATUM( EnableAutoROI,         this->current_config_.enable_auto_roi );
  ADD_DATUM( EnableImageStats,      this->current_config_.enable_image_stats );
  ADD_DATUM( EnableProfiles,        this->current_config_.enable_profile );
  ADD_DATUM( EnableHistogram,       this->current_config_.enable_histogram );
  ADD_DATUM( EnableUserROI,         this->current_config_.enable_user_roi );
  ADD_DATUM( PixelSizeX,            this->current_config_.pixel_size_x );
  ADD_DATUM( PixelSizeY,            this->current_config_.pixel_size_y );
  ADD_DATUM( OpticalMagnification,  this->current_config_.optical_mag );
  ADD_DATUM( userROIOriginX,    static_cast<long>(this->current_config_.user_roi_origin_x ));
  ADD_DATUM( userROIOriginY,    static_cast<long>(this->current_config_.user_roi_origin_y ));
  ADD_DATUM( userROIWidth,      static_cast<long>(this->current_config_.user_roi_width ));
  ADD_DATUM( userROIHeight,      static_cast<long>(this->current_config_.user_roi_height ));
  ADD_DATUM( Rotation,              static_cast<long>(this->current_config_.rotation ));
  ADD_DATUM( HorizontalFlip,        this->current_config_.horizontal_flip );
  ADD_DATUM( GammaCorrection,       this->current_config_.gamma_correction );
  ADD_DATUM( BitsPerPixel,          static_cast<long>(this->current_config_.pixel_depth ));
  ADD_DATUM( HistogramNbBins,       static_cast<long>(this->current_config_.histo_nb_bins ));
  ADD_DATUM( HistogramRangeMin,     static_cast<long>(this->current_config_.histo_range_min ));
  ADD_DATUM( HistogramRangeMax,     static_cast<long>(this->current_config_.histo_range_max ));
  ADD_DATUM( ProfileFitFixedBg,     this->current_config_.profilefit_fixedbg );

  ADD_DATUM( ChamberOffsetX,     this->current_config_.chamber_offset_x );
  ADD_DATUM( ChamberOffsetY,     this->current_config_.chamber_offset_y );

  ADD_DATUM( CentroidSaturationRegionSide, static_cast<long>(this->current_config_.centroid_saturation_region_side ));
  ADD_DATUM( CentroidSaturationRegionThreshold, static_cast<long>(this->current_config_.centroid_saturation_region_threshold ));

# undef ADD_DATUM

  try 
  {
    //- write properties to tango database
    this->get_db_device()->put_property(data);
  }
  catch (Tango::DevFailed& ex)
  {
    RETHROW_DEVFAILED(ex,
                      "DATABASE_FAILURE",
                      "Could not save current device settings into TANGO database",
                      "ImgBeamAnalyzer::save_current_settings");
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Could not save current device settings into TANGO database",
                    "ImgBeamAnalyzer::save_current_settings");
  }

}

//+------------------------------------------------------------------
/**
 *	method:	ImgBeamAnalyzer::get_version_number
 *
 *	description:	method to execute "GetVersionNumber"
 *
 * @return	the Device Server version number
 *
 */
//+------------------------------------------------------------------
Tango::DevString ImgBeamAnalyzer::get_version_number()
{
  //  POGO has generated a method core with argout allocation.
  //  If you would like to use a static reference without copying,
  //  See "TANGO Device Server Programmer's Manual"
  //    (chapter : Writing a TANGO DS / Exchanging data)
  //------------------------------------------------------------
  string version(BIA_VERSION);
  Tango::DevString  argout  = new char[version.length()];
  ::strcpy(argout, version.c_str());
  return argout;
}


void ImgBeamAnalyzer::update_state()
{
  if (this->properly_initialized_ == false)
  {
    //- the state and status are set up during init()
    //- just do nothing here...
  }
  else if (this->task_)
  {
    ImgBeamAnalyzerTask::State state;
    std::string status;
    this->task_->get_state_status(state, status);
    
    Tango::DevState tango_state;
    switch(state)
    {
    case ImgBeamAnalyzerTask::INIT:    tango_state = Tango::INIT;    break;
    case ImgBeamAnalyzerTask::STANDBY: tango_state = Tango::STANDBY; break;
    case ImgBeamAnalyzerTask::RUNNING: tango_state = Tango::RUNNING; break;
    case ImgBeamAnalyzerTask::FAULT:   tango_state = Tango::FAULT;   break;
    default:                           tango_state = Tango::UNKNOWN; break;
    }

    if (    (state == ImgBeamAnalyzerTask::STANDBY)
         && this->image_source_
         && this->image_source_->observer_registered()) {
        tango_state = Tango::RUNNING;
    }

    this->set_state (tango_state);
    this->set_status(status);
  }
};




























}	//	namespace
