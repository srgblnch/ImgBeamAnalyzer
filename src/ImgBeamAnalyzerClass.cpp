static const char *RcsId     = "$Header: /users/chaize/newsvn/cvsroot/Calculation/ImgBeamAnalyzer/src/ImgBeamAnalyzerClass.cpp,v 1.3 2006-12-19 13:25:08 julien_malik Exp $";
static const char *TagName   = "$Name: not supported by cvs2svn $";
static const char *HttpServer= "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        ImgBeamAnalyzerClass.cpp
//
// description : C++ source for the ImgBeamAnalyzerClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the ImgBeamAnalyzer once per process.
//
// project :     TANGO Device Server
//
// $Author: julien_malik $
//
// $Revision: 1.3 $
//
// $Log: not supported by cvs2svn $
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


#include <ImgBeamAnalyzer.h>
#include <ImgBeamAnalyzerClass.h>


namespace ImgBeamAnalyzer_ns
{
//+----------------------------------------------------------------------------
//
// method : 		StopLearnNoiseCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StopLearnNoiseCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StopLearnNoiseCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->stop_learn_noise());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StartLearnNoiseCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartLearnNoiseCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartLearnNoiseCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->start_learn_noise());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		ProcessCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ProcessCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ProcessCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->process());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		SaveCurrentSettingsCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *SaveCurrentSettingsCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "SaveCurrentSettingsCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->save_current_settings());
	return new CORBA::Any();
}


//+----------------------------------------------------------------------------
//
// method : 		StopCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StopCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StopCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->stop());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StartCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartCmd::execute(): arrived" << endl;

	((static_cast<ImgBeamAnalyzer *>(device))->start());
	return new CORBA::Any();
}


//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
ImgBeamAnalyzerClass *ImgBeamAnalyzerClass::_instance = NULL;

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::ImgBeamAnalyzerClass(string &s)
// 
// description : 	constructor for the ImgBeamAnalyzerClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
ImgBeamAnalyzerClass::ImgBeamAnalyzerClass(string &s):DeviceClass(s)
{

	cout2 << "Entering ImgBeamAnalyzerClass constructor" << endl;
	get_class_property();
	set_default_property();
	write_class_property();
	
	cout2 << "Leaving ImgBeamAnalyzerClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::~ImgBeamAnalyzerClass()
// 
// description : 	destructor for the ImgBeamAnalyzerClass
//
//-----------------------------------------------------------------------------
ImgBeamAnalyzerClass::~ImgBeamAnalyzerClass()
{
	_instance = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::instance
// 
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
ImgBeamAnalyzerClass *ImgBeamAnalyzerClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new ImgBeamAnalyzerClass(s);
		}
		catch (bad_alloc)
		{
			throw;
		}		
	}		
	return _instance;
}

ImgBeamAnalyzerClass *ImgBeamAnalyzerClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::command_factory()
{
	command_list.push_back(new StartCmd("Start",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StopCmd("Stop",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new ProcessCmd("Process",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new SaveCurrentSettingsCmd("SaveCurrentSettings",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StartLearnNoiseCmd("StartLearnNoise",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StopLearnNoiseCmd("StopLearnNoise",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
	}
}

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::get_class_property
// 
// description : 	Get the class property for specified name.
//
// in :		string	name : The property name
//
//+----------------------------------------------------------------------------
Tango::DbDatum ImgBeamAnalyzerClass::get_class_property(string &prop_name)
{
	for (int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::get_default_device_property()
// 
// description : 	Return the default value for device property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum ImgBeamAnalyzerClass::get_default_device_property(string &prop_name)
{
	for (int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::get_default_class_property()
// 
// description : 	Return the default value for class property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum ImgBeamAnalyzerClass::get_default_class_property(string &prop_name)
{
	for (int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::device_factory
// 
// description : 	Create the device object(s) and store them in the 
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{

	//	Create all devices.(Automatic code generation)
	//-------------------------------------------------------------
	for (unsigned long i=0 ; i < devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
						
		// Create devices and add it into the device list
		//----------------------------------------------------
		device_list.push_back(new ImgBeamAnalyzer(this, (*devlist_ptr)[i]));							 

		// Export device to the outside world
		// Check before if database used.
		//---------------------------------------------
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(device_list.back());
		else
			export_device(device_list.back(), (*devlist_ptr)[i]);
	}
	//	End of Automatic code generation
	//-------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//	Method: ImgBeamAnalyzerClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	//	Attribute : EnableImageStats
	EnableImageStatsAttrib	*enable_image_stats = new EnableImageStatsAttrib();
	Tango::UserDefaultAttrProp	enable_image_stats_prop;
	enable_image_stats_prop.set_label("EnableImageStats");
	enable_image_stats_prop.set_description("enables the computation of image moments (centroid, variance, skew) and maximal intensity");
	enable_image_stats->set_default_properties(enable_image_stats_prop);
	att_list.push_back(enable_image_stats);

	//	Attribute : EnableProfiles
	EnableProfilesAttrib	*enable_profiles = new EnableProfilesAttrib();
	Tango::UserDefaultAttrProp	enable_profiles_prop;
	enable_profiles_prop.set_label("EnableProfiles");
	enable_profiles_prop.set_description("enables the computation of the X and Y profiles, and the corresponding gaussian fit");
	enable_profiles->set_default_properties(enable_profiles_prop);
	att_list.push_back(enable_profiles);

	//	Attribute : EnableUserROI
	EnableUserROIAttrib	*enable_user_roi = new EnableUserROIAttrib();
	Tango::UserDefaultAttrProp	enable_user_roi_prop;
	enable_user_roi_prop.set_label("EnableUserROI");
	enable_user_roi_prop.set_description("enables the use of the UserROIOriginX, UserROIOriginY, UserROIWidth, UserROIHeight to define the ROI that will be processed");
	enable_user_roi->set_default_properties(enable_user_roi_prop);
	att_list.push_back(enable_user_roi);

	//	Attribute : EnableAutoROI
	EnableAutoROIAttrib	*enable_auto_roi = new EnableAutoROIAttrib();
	Tango::UserDefaultAttrProp	enable_auto_roi_prop;
	enable_auto_roi_prop.set_label("EnableAutoROI");
	enable_auto_roi_prop.set_description("if true, the ROI is detected automatically to encompass the biggest particle in the image");
	enable_auto_roi->set_default_properties(enable_auto_roi_prop);
	att_list.push_back(enable_auto_roi);

	//	Attribute : Enable2DGaussianFit
	Enable2DGaussianFitAttrib	*enable2_dgaussian_fit = new Enable2DGaussianFitAttrib();
	Tango::UserDefaultAttrProp	enable2_dgaussian_fit_prop;
	enable2_dgaussian_fit_prop.set_label("Enable2DGaussianFit");
	enable2_dgaussian_fit_prop.set_description("enables the 2D gaussian fitting");
	enable2_dgaussian_fit->set_default_properties(enable2_dgaussian_fit_prop);
	att_list.push_back(enable2_dgaussian_fit);

	//	Attribute : ComputationPeriod
	ComputationPeriodAttrib	*computation_period = new ComputationPeriodAttrib();
	Tango::UserDefaultAttrProp	computation_period_prop;
	computation_period_prop.set_label("ComputationPeriod");
	computation_period_prop.set_unit("ms");
	computation_period_prop.set_format("%4d");
	computation_period_prop.set_description("period in millisecond at which a new image is read and processed");
	computation_period->set_default_properties(computation_period_prop);
	att_list.push_back(computation_period);

	//	Attribute : EstimComputTime
	EstimComputTimeAttrib	*estim_comput_time = new EstimComputTimeAttrib();
	Tango::UserDefaultAttrProp	estim_comput_time_prop;
	estim_comput_time_prop.set_label("EstimComputTime");
	estim_comput_time_prop.set_unit("ms");
	estim_comput_time_prop.set_format("%5d");
	estim_comput_time_prop.set_description("time spent, in ms, to process the image");
	estim_comput_time->set_default_properties(estim_comput_time_prop);
	att_list.push_back(estim_comput_time);

	//	Attribute : Rotation
	RotationAttrib	*rotation = new RotationAttrib();
	Tango::UserDefaultAttrProp	rotation_prop;
	rotation_prop.set_label("Rotation");
	rotation_prop.set_unit("°");
	rotation_prop.set_format("%4d");
	rotation_prop.set_description("the rotation applied in preprocessing. only multiple of 90 are recognized as valid values");
	rotation->set_default_properties(rotation_prop);
	att_list.push_back(rotation);

	//	Attribute : HorizontalFlip
	HorizontalFlipAttrib	*horizontal_flip = new HorizontalFlipAttrib();
	Tango::UserDefaultAttrProp	horizontal_flip_prop;
	horizontal_flip_prop.set_label("HorizontalFlip");
	horizontal_flip_prop.set_description("if true, the image is flipped horizontally in preprocessing, after having been rotated");
	horizontal_flip->set_default_properties(horizontal_flip_prop);
	att_list.push_back(horizontal_flip);

	//	Attribute : BitsPerPixel
	BitsPerPixelAttrib	*bits_per_pixel = new BitsPerPixelAttrib();
	Tango::UserDefaultAttrProp	bits_per_pixel_prop;
	bits_per_pixel_prop.set_label("BitsPerPixel");
	bits_per_pixel_prop.set_unit(" ");
	bits_per_pixel_prop.set_format("%2d");
	bits_per_pixel_prop.set_description("the pixel depth for significative information in the image (usually 8 or 10).\nit is used only in the gamma correction to keep a constant dynamic range of pixel values when raising these values to a power");
	bits_per_pixel->set_default_properties(bits_per_pixel_prop);
	att_list.push_back(bits_per_pixel);

	//	Attribute : GammaCorrection
	GammaCorrectionAttrib	*gamma_correction = new GammaCorrectionAttrib();
	Tango::UserDefaultAttrProp	gamma_correction_prop;
	gamma_correction_prop.set_label("GammaCorrection");
	gamma_correction_prop.set_unit(" ");
	gamma_correction_prop.set_format("%6.5f");
	gamma_correction_prop.set_description("the gamma value of the camera, used to correct the ROI image by raising to its inverse power");
	gamma_correction->set_default_properties(gamma_correction_prop);
	att_list.push_back(gamma_correction);

	//	Attribute : Threshold
	ThresholdAttrib	*threshold = new ThresholdAttrib();
	Tango::UserDefaultAttrProp	threshold_prop;
	threshold_prop.set_label("Threshold");
	threshold_prop.set_unit(" ");
	threshold_prop.set_format("%6.1f");
	threshold_prop.set_description("the threshold level, used to binarize the image");
	threshold->set_default_properties(threshold_prop);
	att_list.push_back(threshold);

	//	Attribute : AutoROIMagFactor
	AutoROIMagFactorAttrib	*auto_roimag_factor = new AutoROIMagFactorAttrib();
	Tango::UserDefaultAttrProp	auto_roimag_factor_prop;
	auto_roimag_factor_prop.set_label("AutoROI Magnification Factor");
	auto_roimag_factor_prop.set_unit(" ");
	auto_roimag_factor_prop.set_format("%3.2f");
	auto_roimag_factor_prop.set_description("the scaling factor applied to the bounding rectangle of the longest contour to define the ROI automatically");
	auto_roimag_factor->set_default_properties(auto_roimag_factor_prop);
	att_list.push_back(auto_roimag_factor);

	//	Attribute : AlarmZone
	AlarmZoneAttrib	*alarm_zone = new AlarmZoneAttrib();
	Tango::UserDefaultAttrProp	alarm_zone_prop;
	alarm_zone_prop.set_label("AlarmZone");
	alarm_zone_prop.set_unit("pix");
	alarm_zone_prop.set_format("%3d");
	alarm_zone_prop.set_min_value("0");
	alarm_zone_prop.set_description("if EnableAutoROI is set to true and if the distance between a beam box corner and the border of the image falls below this threshold, attributes quality are set to ALARM");
	alarm_zone->set_default_properties(alarm_zone_prop);
	att_list.push_back(alarm_zone);

	//	Attribute : PixelSize
	PixelSizeAttrib	*pixel_size = new PixelSizeAttrib();
	Tango::UserDefaultAttrProp	pixel_size_prop;
	pixel_size_prop.set_label("PixelSize");
	pixel_size_prop.set_unit("mm/pix");
	pixel_size_prop.set_format("%5.4f");
	pixel_size_prop.set_description("The correspondence between pixel and mm");
	pixel_size->set_default_properties(pixel_size_prop);
	att_list.push_back(pixel_size);

	//	Attribute : UserROIOriginX
	UserROIOriginXAttrib	*user_roiorigin_x = new UserROIOriginXAttrib();
	Tango::UserDefaultAttrProp	user_roiorigin_x_prop;
	user_roiorigin_x_prop.set_label("User ROI Origin X");
	user_roiorigin_x_prop.set_unit("pix");
	user_roiorigin_x_prop.set_format("%4d");
	user_roiorigin_x_prop.set_min_value("0");
	user_roiorigin_x_prop.set_description("the X coordinate of the origin of the ROI (up-left corner) in pixels");
	user_roiorigin_x->set_default_properties(user_roiorigin_x_prop);
	att_list.push_back(user_roiorigin_x);

	//	Attribute : UserROIOriginY
	UserROIOriginYAttrib	*user_roiorigin_y = new UserROIOriginYAttrib();
	Tango::UserDefaultAttrProp	user_roiorigin_y_prop;
	user_roiorigin_y_prop.set_label("User ROI Origin Y");
	user_roiorigin_y_prop.set_unit("pix");
	user_roiorigin_y_prop.set_format("%4d");
	user_roiorigin_y_prop.set_min_value("0");
	user_roiorigin_y_prop.set_description("the Y coordinate of the origin of the ROI (up-left corner)");
	user_roiorigin_y->set_default_properties(user_roiorigin_y_prop);
	att_list.push_back(user_roiorigin_y);

	//	Attribute : UserROIWidth
	UserROIWidthAttrib	*user_roiwidth = new UserROIWidthAttrib();
	Tango::UserDefaultAttrProp	user_roiwidth_prop;
	user_roiwidth_prop.set_label("User ROI Width");
	user_roiwidth_prop.set_unit("pix");
	user_roiwidth_prop.set_format("%4d");
	user_roiwidth_prop.set_min_value("0");
	user_roiwidth_prop.set_description("the width of the ROI in pixels");
	user_roiwidth->set_default_properties(user_roiwidth_prop);
	att_list.push_back(user_roiwidth);

	//	Attribute : UserROIHeight
	UserROIHeightAttrib	*user_roiheight = new UserROIHeightAttrib();
	Tango::UserDefaultAttrProp	user_roiheight_prop;
	user_roiheight_prop.set_label("User ROI Height");
	user_roiheight_prop.set_unit("pix");
	user_roiheight_prop.set_format("%4d");
	user_roiheight_prop.set_min_value("0");
	user_roiheight_prop.set_description("the height of the ROI in pixels");
	user_roiheight->set_default_properties(user_roiheight_prop);
	att_list.push_back(user_roiheight);

	//	Attribute : AutoROIOriginX
	AutoROIOriginXAttrib	*auto_roiorigin_x = new AutoROIOriginXAttrib();
	Tango::UserDefaultAttrProp	auto_roiorigin_x_prop;
	auto_roiorigin_x_prop.set_label("Auto ROI Origin X");
	auto_roiorigin_x_prop.set_unit("pix");
	auto_roiorigin_x_prop.set_format("%4d");
	auto_roiorigin_x_prop.set_description("the X coordinate of the origin of the ROI (up-left corner) in pixels");
	auto_roiorigin_x->set_default_properties(auto_roiorigin_x_prop);
	att_list.push_back(auto_roiorigin_x);

	//	Attribute : AutoROIOriginY
	AutoROIOriginYAttrib	*auto_roiorigin_y = new AutoROIOriginYAttrib();
	Tango::UserDefaultAttrProp	auto_roiorigin_y_prop;
	auto_roiorigin_y_prop.set_label("Auto ROI Origin Y");
	auto_roiorigin_y_prop.set_unit("pix");
	auto_roiorigin_y_prop.set_format("%4d");
	auto_roiorigin_y_prop.set_description("the Y coordinate of the origin of the ROI (up-left corner) in pixels");
	auto_roiorigin_y->set_default_properties(auto_roiorigin_y_prop);
	att_list.push_back(auto_roiorigin_y);

	//	Attribute : AutoROIWidth
	AutoROIWidthAttrib	*auto_roiwidth = new AutoROIWidthAttrib();
	Tango::UserDefaultAttrProp	auto_roiwidth_prop;
	auto_roiwidth_prop.set_label("Auto ROI Width");
	auto_roiwidth_prop.set_unit("pix");
	auto_roiwidth_prop.set_format("%4d");
	auto_roiwidth_prop.set_description("the width of the automatically detected ROI");
	auto_roiwidth->set_default_properties(auto_roiwidth_prop);
	att_list.push_back(auto_roiwidth);

	//	Attribute : AutoROIHeight
	AutoROIHeightAttrib	*auto_roiheight = new AutoROIHeightAttrib();
	Tango::UserDefaultAttrProp	auto_roiheight_prop;
	auto_roiheight_prop.set_label("Auto ROI Height");
	auto_roiheight_prop.set_unit("pix");
	auto_roiheight_prop.set_format("%4d");
	auto_roiheight_prop.set_description("the height of the automatically detected ROI");
	auto_roiheight->set_default_properties(auto_roiheight_prop);
	att_list.push_back(auto_roiheight);

	//	Attribute : NbNoiseImage
	NbNoiseImageAttrib	*nb_noise_image = new NbNoiseImageAttrib();
	Tango::UserDefaultAttrProp	nb_noise_image_prop;
	nb_noise_image_prop.set_label("NbNoiseImage");
	nb_noise_image_prop.set_unit(" ");
	nb_noise_image_prop.set_format("%3d");
	nb_noise_image_prop.set_description("the number of noise image used to estimate the mean noise image");
	nb_noise_image->set_default_properties(nb_noise_image_prop);
	att_list.push_back(nb_noise_image);

	//	Attribute : InputImage
	InputImageAttrib	*input_image = new InputImageAttrib();
	Tango::UserDefaultAttrProp	input_image_prop;
	input_image_prop.set_label("InputImage");
	input_image_prop.set_description("raw copy of the input image");
	input_image->set_default_properties(input_image_prop);
	att_list.push_back(input_image);

	//	Attribute : ROIImage
	ROIImageAttrib	*roiimage = new ROIImageAttrib();
	Tango::UserDefaultAttrProp	roiimage_prop;
	roiimage_prop.set_label("ROI Image");
	roiimage_prop.set_unit(" ");
	roiimage_prop.set_description("the effective image on which are done all the calculation");
	roiimage->set_default_properties(roiimage_prop);
	att_list.push_back(roiimage);

	//	Attribute : MeanNoiseImage
	MeanNoiseImageAttrib	*mean_noise_image = new MeanNoiseImageAttrib();
	Tango::UserDefaultAttrProp	mean_noise_image_prop;
	mean_noise_image_prop.set_label("Mean Noise Image");
	mean_noise_image_prop.set_unit(" ");
	mean_noise_image_prop.set_description("the mean noise image, which is substracted from every processed image");
	mean_noise_image->set_default_properties(mean_noise_image_prop);
	mean_noise_image->set_disp_level(Tango::EXPERT);
	att_list.push_back(mean_noise_image);

	//	Attribute : ThresholdedImage
	ThresholdedImageAttrib	*thresholded_image = new ThresholdedImageAttrib();
	Tango::UserDefaultAttrProp	thresholded_image_prop;
	thresholded_image_prop.set_label("ThresholdedImage");
	thresholded_image_prop.set_unit(" ");
	thresholded_image_prop.set_description("the binarized image after applying the threshold");
	thresholded_image->set_default_properties(thresholded_image_prop);
	thresholded_image->set_disp_level(Tango::EXPERT);
	att_list.push_back(thresholded_image);

	//	Attribute : MaxIntensity
	MaxIntensityAttrib	*max_intensity = new MaxIntensityAttrib();
	Tango::UserDefaultAttrProp	max_intensity_prop;
	max_intensity_prop.set_label("MaxIntensity");
	max_intensity_prop.set_unit(" ");
	max_intensity_prop.set_format("%10.2f");
	max_intensity_prop.set_description("the maximal intensity inside the ROI");
	max_intensity->set_default_properties(max_intensity_prop);
	att_list.push_back(max_intensity);

	//	Attribute : MeanIntensity
	MeanIntensityAttrib	*mean_intensity = new MeanIntensityAttrib();
	Tango::UserDefaultAttrProp	mean_intensity_prop;
	mean_intensity_prop.set_label("MeanIntensity");
	mean_intensity_prop.set_unit(" ");
	mean_intensity_prop.set_format("%10.2f");
	mean_intensity_prop.set_description("the mean intensity inside the beam box");
	mean_intensity->set_default_properties(mean_intensity_prop);
	att_list.push_back(mean_intensity);

	//	Attribute : CentroidX
	CentroidXAttrib	*centroid_x = new CentroidXAttrib();
	Tango::UserDefaultAttrProp	centroid_x_prop;
	centroid_x_prop.set_label("CentroidX");
	centroid_x_prop.set_unit("mm");
	centroid_x_prop.set_format("%10.2f");
	centroid_x_prop.set_description("the X coordinate of the centroid");
	centroid_x->set_default_properties(centroid_x_prop);
	att_list.push_back(centroid_x);

	//	Attribute : CentroidY
	CentroidYAttrib	*centroid_y = new CentroidYAttrib();
	Tango::UserDefaultAttrProp	centroid_y_prop;
	centroid_y_prop.set_label("CentroidY");
	centroid_y_prop.set_unit("mm");
	centroid_y_prop.set_format("%10.2f");
	centroid_y_prop.set_description("the Y coordinate of the centroid");
	centroid_y->set_default_properties(centroid_y_prop);
	att_list.push_back(centroid_y);

	//	Attribute : VarianceX
	VarianceXAttrib	*variance_x = new VarianceXAttrib();
	Tango::UserDefaultAttrProp	variance_x_prop;
	variance_x_prop.set_label("VarianceX");
	variance_x_prop.set_unit("mm²");
	variance_x_prop.set_format("%10.2f");
	variance_x_prop.set_description("the variance along the X axis");
	variance_x->set_default_properties(variance_x_prop);
	att_list.push_back(variance_x);

	//	Attribute : VarianceY
	VarianceYAttrib	*variance_y = new VarianceYAttrib();
	Tango::UserDefaultAttrProp	variance_y_prop;
	variance_y_prop.set_label("VarianceY");
	variance_y_prop.set_unit("mm²");
	variance_y_prop.set_format("%10.2f");
	variance_y_prop.set_description("the variance along the Y axis");
	variance_y->set_default_properties(variance_y_prop);
	att_list.push_back(variance_y);

	//	Attribute : CovarianceXY
	CovarianceXYAttrib	*covariance_xy = new CovarianceXYAttrib();
	Tango::UserDefaultAttrProp	covariance_xy_prop;
	covariance_xy_prop.set_label("Covariance X-Y");
	covariance_xy_prop.set_unit("mm²");
	covariance_xy_prop.set_format("%10.2f");
	covariance_xy_prop.set_description("the covariance with respect to the X and Y axis");
	covariance_xy->set_default_properties(covariance_xy_prop);
	att_list.push_back(covariance_xy);

	//	Attribute : CorrelationXY
	CorrelationXYAttrib	*correlation_xy = new CorrelationXYAttrib();
	Tango::UserDefaultAttrProp	correlation_xy_prop;
	correlation_xy_prop.set_label("Correlation Coefficient");
	correlation_xy_prop.set_unit(" ");
	correlation_xy_prop.set_format("%10.2f");
	correlation_xy_prop.set_description("the correlation coefficient between the X and Y axises");
	correlation_xy->set_default_properties(correlation_xy_prop);
	att_list.push_back(correlation_xy);

	//	Attribute : SkewX
	SkewXAttrib	*skew_x = new SkewXAttrib();
	Tango::UserDefaultAttrProp	skew_x_prop;
	skew_x_prop.set_label("Skew X^3");
	skew_x_prop.set_unit("mm3");
	skew_x_prop.set_format("%10.2f");
	skew_x_prop.set_description("the skew along the X axis");
	skew_x->set_default_properties(skew_x_prop);
	att_list.push_back(skew_x);

	//	Attribute : SkewY
	SkewYAttrib	*skew_y = new SkewYAttrib();
	Tango::UserDefaultAttrProp	skew_y_prop;
	skew_y_prop.set_label("Skew Y^3");
	skew_y_prop.set_unit("mm3");
	skew_y_prop.set_format("%10.2f");
	skew_y_prop.set_description("the skew along the Y axis");
	skew_y->set_default_properties(skew_y_prop);
	att_list.push_back(skew_y);

	//	Attribute : SkewX2Y
	SkewX2YAttrib	*skew_x2_y = new SkewX2YAttrib();
	Tango::UserDefaultAttrProp	skew_x2_y_prop;
	skew_x2_y_prop.set_label("Skew X².Y");
	skew_x2_y_prop.set_unit("mm3");
	skew_x2_y_prop.set_format("%10.2f");
	skew_x2_y_prop.set_description("the skew cross coefficient for X².Y");
	skew_x2_y->set_default_properties(skew_x2_y_prop);
	att_list.push_back(skew_x2_y);

	//	Attribute : SkewXY2
	SkewXY2Attrib	*skew_xy2 = new SkewXY2Attrib();
	Tango::UserDefaultAttrProp	skew_xy2_prop;
	skew_xy2_prop.set_label("Skew X.Y²");
	skew_xy2_prop.set_unit("mm3");
	skew_xy2_prop.set_format("%10.2f");
	skew_xy2_prop.set_description("the skew cross coefficient for X.Y²");
	skew_xy2->set_default_properties(skew_xy2_prop);
	att_list.push_back(skew_xy2);

	//	Attribute : EllipseCentroidX
	EllipseCentroidXAttrib	*ellipse_centroid_x = new EllipseCentroidXAttrib();
	Tango::UserDefaultAttrProp	ellipse_centroid_x_prop;
	ellipse_centroid_x_prop.set_label("EllipseCentroidX");
	ellipse_centroid_x_prop.set_unit("mm");
	ellipse_centroid_x_prop.set_format("%10.2f");
	ellipse_centroid_x_prop.set_description("the X coordinate of the centroid of the fitted ellipse");
	ellipse_centroid_x->set_default_properties(ellipse_centroid_x_prop);
	att_list.push_back(ellipse_centroid_x);

	//	Attribute : EllipseCentroidY
	EllipseCentroidYAttrib	*ellipse_centroid_y = new EllipseCentroidYAttrib();
	Tango::UserDefaultAttrProp	ellipse_centroid_y_prop;
	ellipse_centroid_y_prop.set_label("EllipseCentroidY");
	ellipse_centroid_y_prop.set_unit("mm");
	ellipse_centroid_y_prop.set_format("%10.2f");
	ellipse_centroid_y_prop.set_description("the Y coordinate of the centroid of the fitted ellipse");
	ellipse_centroid_y->set_default_properties(ellipse_centroid_y_prop);
	att_list.push_back(ellipse_centroid_y);

	//	Attribute : EllipseMajorAxis
	EllipseMajorAxisAttrib	*ellipse_major_axis = new EllipseMajorAxisAttrib();
	Tango::UserDefaultAttrProp	ellipse_major_axis_prop;
	ellipse_major_axis_prop.set_label("EllipseMajorAxis");
	ellipse_major_axis_prop.set_unit("mm");
	ellipse_major_axis_prop.set_format("%10.2f");
	ellipse_major_axis_prop.set_description("the major axis (full axis, not half) of the beam ellipse");
	ellipse_major_axis->set_default_properties(ellipse_major_axis_prop);
	att_list.push_back(ellipse_major_axis);

	//	Attribute : EllipseMinorAxis
	EllipseMinorAxisAttrib	*ellipse_minor_axis = new EllipseMinorAxisAttrib();
	Tango::UserDefaultAttrProp	ellipse_minor_axis_prop;
	ellipse_minor_axis_prop.set_label("EllipseMinorAxis");
	ellipse_minor_axis_prop.set_unit("mm");
	ellipse_minor_axis_prop.set_format("%10.2f");
	ellipse_minor_axis_prop.set_description("the minor axis (full axis, not half) of the beam ellipse");
	ellipse_minor_axis->set_default_properties(ellipse_minor_axis_prop);
	att_list.push_back(ellipse_minor_axis);

	//	Attribute : EllipseTilt
	EllipseTiltAttrib	*ellipse_tilt = new EllipseTiltAttrib();
	Tango::UserDefaultAttrProp	ellipse_tilt_prop;
	ellipse_tilt_prop.set_label("EllipseTilt");
	ellipse_tilt_prop.set_unit("rad");
	ellipse_tilt_prop.set_format("%10.2f");
	ellipse_tilt_prop.set_description("the orientation of the beam ellipse from the X axis");
	ellipse_tilt->set_default_properties(ellipse_tilt_prop);
	att_list.push_back(ellipse_tilt);

	//	Attribute : XProfile
	XProfileAttrib	*xprofile = new XProfileAttrib();
	Tango::UserDefaultAttrProp	xprofile_prop;
	xprofile_prop.set_label("XProfile");
	xprofile_prop.set_unit(" ");
	xprofile_prop.set_format("%10.2f");
	xprofile_prop.set_description("the cumulative sum along the X axis");
	xprofile->set_default_properties(xprofile_prop);
	att_list.push_back(xprofile);

	//	Attribute : XProfileFitted
	XProfileFittedAttrib	*xprofile_fitted = new XProfileFittedAttrib();
	Tango::UserDefaultAttrProp	xprofile_fitted_prop;
	xprofile_fitted_prop.set_label("XProfileFitted");
	xprofile_fitted_prop.set_unit(" ");
	xprofile_fitted_prop.set_format("%10.2f");
	xprofile_fitted_prop.set_description("the fitted profile along the X axis");
	xprofile_fitted->set_default_properties(xprofile_fitted_prop);
	xprofile_fitted->set_disp_level(Tango::EXPERT);
	att_list.push_back(xprofile_fitted);

	//	Attribute : XProfileError
	XProfileErrorAttrib	*xprofile_error = new XProfileErrorAttrib();
	Tango::UserDefaultAttrProp	xprofile_error_prop;
	xprofile_error_prop.set_label("XProfileError");
	xprofile_error_prop.set_unit(" ");
	xprofile_error_prop.set_format("%10.2f");
	xprofile_error_prop.set_description("the fitted profile error along the X axis");
	xprofile_error->set_default_properties(xprofile_error_prop);
	xprofile_error->set_disp_level(Tango::EXPERT);
	att_list.push_back(xprofile_error);

	//	Attribute : XProfileCenter
	XProfileCenterAttrib	*xprofile_center = new XProfileCenterAttrib();
	Tango::UserDefaultAttrProp	xprofile_center_prop;
	xprofile_center_prop.set_label("XProfile Center");
	xprofile_center_prop.set_unit("mm");
	xprofile_center_prop.set_format("%10.2f");
	xprofile_center_prop.set_description("the X position of the center of the fitted gaussian corresponding to the X profile");
	xprofile_center->set_default_properties(xprofile_center_prop);
	att_list.push_back(xprofile_center);

	//	Attribute : XProfileMag
	XProfileMagAttrib	*xprofile_mag = new XProfileMagAttrib();
	Tango::UserDefaultAttrProp	xprofile_mag_prop;
	xprofile_mag_prop.set_label("XProfile Magnitude");
	xprofile_mag_prop.set_unit(" ");
	xprofile_mag_prop.set_format("%10.2f");
	xprofile_mag_prop.set_description("the magnitude of  fitted gaussian corresponding to the X profile");
	xprofile_mag->set_default_properties(xprofile_mag_prop);
	att_list.push_back(xprofile_mag);

	//	Attribute : XProfileSigma
	XProfileSigmaAttrib	*xprofile_sigma = new XProfileSigmaAttrib();
	Tango::UserDefaultAttrProp	xprofile_sigma_prop;
	xprofile_sigma_prop.set_label("XProfile Sigma");
	xprofile_sigma_prop.set_unit("mm");
	xprofile_sigma_prop.set_format("%10.2f");
	xprofile_sigma_prop.set_description("the standard deviation of  fitted gaussian corresponding to the X profile");
	xprofile_sigma->set_default_properties(xprofile_sigma_prop);
	att_list.push_back(xprofile_sigma);

	//	Attribute : XProfileFWHM
	XProfileFWHMAttrib	*xprofile_fwhm = new XProfileFWHMAttrib();
	Tango::UserDefaultAttrProp	xprofile_fwhm_prop;
	xprofile_fwhm_prop.set_label("XProfile FWHM");
	xprofile_fwhm_prop.set_unit("mm");
	xprofile_fwhm_prop.set_format("%10.2f");
	xprofile_fwhm_prop.set_description("the full width at half maximum of the fitted gaussian corresponding to the X profile, calculated approximately as 2.35 * XProfileSigma");
	xprofile_fwhm->set_default_properties(xprofile_fwhm_prop);
	att_list.push_back(xprofile_fwhm);

	//	Attribute : XProfileBG
	XProfileBGAttrib	*xprofile_bg = new XProfileBGAttrib();
	Tango::UserDefaultAttrProp	xprofile_bg_prop;
	xprofile_bg_prop.set_label("XProfile Background");
	xprofile_bg_prop.set_unit(" ");
	xprofile_bg_prop.set_format("%10.2f");
	xprofile_bg_prop.set_description("the background of  fitted gaussian corresponding to the X profile");
	xprofile_bg->set_default_properties(xprofile_bg_prop);
	att_list.push_back(xprofile_bg);

	//	Attribute : XProfileChi2
	XProfileChi2Attrib	*xprofile_chi2 = new XProfileChi2Attrib();
	Tango::UserDefaultAttrProp	xprofile_chi2_prop;
	xprofile_chi2_prop.set_label("XProfile Chi2");
	xprofile_chi2_prop.set_unit(" ");
	xprofile_chi2_prop.set_format("%10.2f");
	xprofile_chi2_prop.set_description("the chi-2 of  fitted gaussian corresponding to the X profile");
	xprofile_chi2->set_default_properties(xprofile_chi2_prop);
	att_list.push_back(xprofile_chi2);

	//	Attribute : YProfile
	YProfileAttrib	*yprofile = new YProfileAttrib();
	Tango::UserDefaultAttrProp	yprofile_prop;
	yprofile_prop.set_label("YProfile");
	yprofile_prop.set_unit(" ");
	yprofile_prop.set_format("%10.2f");
	yprofile_prop.set_description("the cumulative sum along the Y axis");
	yprofile->set_default_properties(yprofile_prop);
	att_list.push_back(yprofile);

	//	Attribute : YProfileFitted
	YProfileFittedAttrib	*yprofile_fitted = new YProfileFittedAttrib();
	Tango::UserDefaultAttrProp	yprofile_fitted_prop;
	yprofile_fitted_prop.set_label("YProfileFitted");
	yprofile_fitted_prop.set_unit(" ");
	yprofile_fitted_prop.set_format("%10.2f");
	yprofile_fitted_prop.set_description("the fitted profile along the Y axis");
	yprofile_fitted->set_default_properties(yprofile_fitted_prop);
	yprofile_fitted->set_disp_level(Tango::EXPERT);
	att_list.push_back(yprofile_fitted);

	//	Attribute : YProfileError
	YProfileErrorAttrib	*yprofile_error = new YProfileErrorAttrib();
	Tango::UserDefaultAttrProp	yprofile_error_prop;
	yprofile_error_prop.set_label("YProfileError");
	yprofile_error_prop.set_unit(" ");
	yprofile_error_prop.set_format("%10.2f");
	yprofile_error_prop.set_description("the fitted profile error along the Y axis");
	yprofile_error->set_default_properties(yprofile_error_prop);
	yprofile_error->set_disp_level(Tango::EXPERT);
	att_list.push_back(yprofile_error);

	//	Attribute : YProfileCenter
	YProfileCenterAttrib	*yprofile_center = new YProfileCenterAttrib();
	Tango::UserDefaultAttrProp	yprofile_center_prop;
	yprofile_center_prop.set_label("YProfile Center");
	yprofile_center_prop.set_unit("mm");
	yprofile_center_prop.set_format("%10.2f");
	yprofile_center_prop.set_description("the Y position of the center of the fitted gaussian corresponding to the Y profile");
	yprofile_center->set_default_properties(yprofile_center_prop);
	att_list.push_back(yprofile_center);

	//	Attribute : YProfileMag
	YProfileMagAttrib	*yprofile_mag = new YProfileMagAttrib();
	Tango::UserDefaultAttrProp	yprofile_mag_prop;
	yprofile_mag_prop.set_label("YProfile Magnitude");
	yprofile_mag_prop.set_unit(" ");
	yprofile_mag_prop.set_format("%10.2f");
	yprofile_mag_prop.set_description("the magnitude of  fitted gaussian corresponding to the Y profile");
	yprofile_mag->set_default_properties(yprofile_mag_prop);
	att_list.push_back(yprofile_mag);

	//	Attribute : YProfileSigma
	YProfileSigmaAttrib	*yprofile_sigma = new YProfileSigmaAttrib();
	Tango::UserDefaultAttrProp	yprofile_sigma_prop;
	yprofile_sigma_prop.set_label("YProfile Sigma");
	yprofile_sigma_prop.set_unit("mm");
	yprofile_sigma_prop.set_format("%10.2f");
	yprofile_sigma_prop.set_description("the standard deviation of  fitted gaussian corresponding to the Y profile");
	yprofile_sigma->set_default_properties(yprofile_sigma_prop);
	att_list.push_back(yprofile_sigma);

	//	Attribute : YProfileFWHM
	YProfileFWHMAttrib	*yprofile_fwhm = new YProfileFWHMAttrib();
	Tango::UserDefaultAttrProp	yprofile_fwhm_prop;
	yprofile_fwhm_prop.set_label("YProfile FWHM");
	yprofile_fwhm_prop.set_unit("mm");
	yprofile_fwhm_prop.set_format("%10.2f");
	yprofile_fwhm_prop.set_description("the full width at half maximum of the fitted gaussian corresponding to the Y profile, calculated approximately as 2.35 * YProfileSigma");
	yprofile_fwhm->set_default_properties(yprofile_fwhm_prop);
	att_list.push_back(yprofile_fwhm);

	//	Attribute : YProfileBG
	YProfileBGAttrib	*yprofile_bg = new YProfileBGAttrib();
	Tango::UserDefaultAttrProp	yprofile_bg_prop;
	yprofile_bg_prop.set_label("YProfile Background");
	yprofile_bg_prop.set_unit(" ");
	yprofile_bg_prop.set_format("%10.2f");
	yprofile_bg_prop.set_description("the background of  fitted gaussian corresponding to the Y profile");
	yprofile_bg->set_default_properties(yprofile_bg_prop);
	att_list.push_back(yprofile_bg);

	//	Attribute : YProfileChi2
	YProfileChi2Attrib	*yprofile_chi2 = new YProfileChi2Attrib();
	Tango::UserDefaultAttrProp	yprofile_chi2_prop;
	yprofile_chi2_prop.set_label("YProfile Chi2");
	yprofile_chi2_prop.set_unit(" ");
	yprofile_chi2_prop.set_format("%10.2f");
	yprofile_chi2_prop.set_description("the chi-2 of  fitted gaussian corresponding to the Y profile");
	yprofile_chi2->set_default_properties(yprofile_chi2_prop);
	att_list.push_back(yprofile_chi2);

	//	Attribute : GaussianFitMagnitude
	GaussianFitMagnitudeAttrib	*gaussian_fit_magnitude = new GaussianFitMagnitudeAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_magnitude_prop;
	gaussian_fit_magnitude_prop.set_label("GaussianFitMagnitude");
	gaussian_fit_magnitude_prop.set_unit(" ");
	gaussian_fit_magnitude_prop.set_format("%10.2f");
	gaussian_fit_magnitude_prop.set_description("the magnitude of the fitted gaussian");
	gaussian_fit_magnitude->set_default_properties(gaussian_fit_magnitude_prop);
	att_list.push_back(gaussian_fit_magnitude);

	//	Attribute : GaussianFitCenterX
	GaussianFitCenterXAttrib	*gaussian_fit_center_x = new GaussianFitCenterXAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_center_x_prop;
	gaussian_fit_center_x_prop.set_label("GaussianFitCenterX");
	gaussian_fit_center_x_prop.set_unit("mm");
	gaussian_fit_center_x_prop.set_format("%10.2f");
	gaussian_fit_center_x_prop.set_description("the X coordinate of the centroid of the 2D gaussian fitted to the image");
	gaussian_fit_center_x->set_default_properties(gaussian_fit_center_x_prop);
	att_list.push_back(gaussian_fit_center_x);

	//	Attribute : GaussianFitCenterY
	GaussianFitCenterYAttrib	*gaussian_fit_center_y = new GaussianFitCenterYAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_center_y_prop;
	gaussian_fit_center_y_prop.set_label("GaussianFitCenterY");
	gaussian_fit_center_y_prop.set_unit("mm");
	gaussian_fit_center_y_prop.set_format("%10.2f");
	gaussian_fit_center_y_prop.set_description("the Y coordinate of the centroid of the 2D gaussian fitted to the image");
	gaussian_fit_center_y->set_default_properties(gaussian_fit_center_y_prop);
	att_list.push_back(gaussian_fit_center_y);

	//	Attribute : GaussianFitVarianceX
	GaussianFitVarianceXAttrib	*gaussian_fit_variance_x = new GaussianFitVarianceXAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_variance_x_prop;
	gaussian_fit_variance_x_prop.set_label("GaussianFitVarianceX");
	gaussian_fit_variance_x_prop.set_unit("mm²");
	gaussian_fit_variance_x_prop.set_format("%10.2f");
	gaussian_fit_variance_x_prop.set_description("the variance of the 2D gaussian along the X axis");
	gaussian_fit_variance_x->set_default_properties(gaussian_fit_variance_x_prop);
	att_list.push_back(gaussian_fit_variance_x);

	//	Attribute : GaussianFitVarianceY
	GaussianFitVarianceYAttrib	*gaussian_fit_variance_y = new GaussianFitVarianceYAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_variance_y_prop;
	gaussian_fit_variance_y_prop.set_label("GaussianFitVarianceY");
	gaussian_fit_variance_y_prop.set_unit("mm²");
	gaussian_fit_variance_y_prop.set_format("%10.2f");
	gaussian_fit_variance_y_prop.set_description("the variance of the 2D gaussian along the Y axis");
	gaussian_fit_variance_y->set_default_properties(gaussian_fit_variance_y_prop);
	att_list.push_back(gaussian_fit_variance_y);

	//	Attribute : GaussianFitCovarianceXY
	GaussianFitCovarianceXYAttrib	*gaussian_fit_covariance_xy = new GaussianFitCovarianceXYAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_covariance_xy_prop;
	gaussian_fit_covariance_xy_prop.set_label("GaussianFitCovarianceXY");
	gaussian_fit_covariance_xy_prop.set_unit("mm²");
	gaussian_fit_covariance_xy_prop.set_format("%10.2f");
	gaussian_fit_covariance_xy_prop.set_description("the covariance of the 2D gaussian");
	gaussian_fit_covariance_xy->set_default_properties(gaussian_fit_covariance_xy_prop);
	att_list.push_back(gaussian_fit_covariance_xy);

	//	Attribute : GaussianFitMajorAxisFWHM
	GaussianFitMajorAxisFWHMAttrib	*gaussian_fit_major_axis_fwhm = new GaussianFitMajorAxisFWHMAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_major_axis_fwhm_prop;
	gaussian_fit_major_axis_fwhm_prop.set_label("GaussianFitMajorAxisFWHM");
	gaussian_fit_major_axis_fwhm_prop.set_unit("mm");
	gaussian_fit_major_axis_fwhm_prop.set_format("%10.2f");
	gaussian_fit_major_axis_fwhm_prop.set_description("the FWHM along the major axis of the fitted gaussian, calculated approximately as 2.35 * sqrt(GaussianFitVarianceX)");
	gaussian_fit_major_axis_fwhm->set_default_properties(gaussian_fit_major_axis_fwhm_prop);
	att_list.push_back(gaussian_fit_major_axis_fwhm);

	//	Attribute : GaussianFitMinorAxisFWHM
	GaussianFitMinorAxisFWHMAttrib	*gaussian_fit_minor_axis_fwhm = new GaussianFitMinorAxisFWHMAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_minor_axis_fwhm_prop;
	gaussian_fit_minor_axis_fwhm_prop.set_label("GaussianFitMinorAxisFWHM");
	gaussian_fit_minor_axis_fwhm_prop.set_unit("mm");
	gaussian_fit_minor_axis_fwhm_prop.set_format("%10.2f");
	gaussian_fit_minor_axis_fwhm_prop.set_description("the FWHM along the minor axis of the fitted gaussian, calculated approximately as 2.35 * sqrt(GaussianFitVarianceY)");
	gaussian_fit_minor_axis_fwhm->set_default_properties(gaussian_fit_minor_axis_fwhm_prop);
	att_list.push_back(gaussian_fit_minor_axis_fwhm);

	//	Attribute : GaussianFitTilt
	GaussianFitTiltAttrib	*gaussian_fit_tilt = new GaussianFitTiltAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_tilt_prop;
	gaussian_fit_tilt_prop.set_label("GaussianFitTilt");
	gaussian_fit_tilt_prop.set_unit("rad");
	gaussian_fit_tilt_prop.set_format("%10.2f");
	gaussian_fit_tilt_prop.set_description("the angle made by the major axis of the gaussian and the X axis");
	gaussian_fit_tilt->set_default_properties(gaussian_fit_tilt_prop);
	att_list.push_back(gaussian_fit_tilt);

	//	Attribute : GaussianFitBG
	GaussianFitBGAttrib	*gaussian_fit_bg = new GaussianFitBGAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_bg_prop;
	gaussian_fit_bg_prop.set_label("GaussianFitBG");
	gaussian_fit_bg_prop.set_unit(" ");
	gaussian_fit_bg_prop.set_format("%10.2f");
	gaussian_fit_bg_prop.set_description("the background of the fitted gaussian");
	gaussian_fit_bg->set_default_properties(gaussian_fit_bg_prop);
	att_list.push_back(gaussian_fit_bg);

	//	Attribute : GaussianFitChi2
	GaussianFitChi2Attrib	*gaussian_fit_chi2 = new GaussianFitChi2Attrib();
	Tango::UserDefaultAttrProp	gaussian_fit_chi2_prop;
	gaussian_fit_chi2_prop.set_label("GaussianFitChi2");
	gaussian_fit_chi2_prop.set_unit(" ");
	gaussian_fit_chi2_prop.set_format("%10.2f");
	gaussian_fit_chi2_prop.set_description("the chi-2 of the fitted gaussian");
	gaussian_fit_chi2->set_default_properties(gaussian_fit_chi2_prop);
	att_list.push_back(gaussian_fit_chi2);

	//	Attribute : GaussianFitParameterCovariance
	GaussianFitParameterCovarianceAttrib	*gaussian_fit_parameter_covariance = new GaussianFitParameterCovarianceAttrib();
	Tango::UserDefaultAttrProp	gaussian_fit_parameter_covariance_prop;
	gaussian_fit_parameter_covariance_prop.set_label("GaussianFitParameterCovariance");
	gaussian_fit_parameter_covariance_prop.set_unit(" ");
	gaussian_fit_parameter_covariance_prop.set_format("%10.2f");
	gaussian_fit_parameter_covariance_prop.set_description("the covariance matrix of the best fit parameters (7x7). the 7 parameters are ordered as [A, x_c, y_c, s_xx, s_xy, s_yy, b]");
	gaussian_fit_parameter_covariance->set_default_properties(gaussian_fit_parameter_covariance_prop);
	gaussian_fit_parameter_covariance->set_disp_level(Tango::EXPERT);
	att_list.push_back(gaussian_fit_parameter_covariance);

	//	Attribute : Fit2DNbIterMax
	Fit2DNbIterMaxAttrib	*fit2_dnb_iter_max = new Fit2DNbIterMaxAttrib();
	Tango::UserDefaultAttrProp	fit2_dnb_iter_max_prop;
	fit2_dnb_iter_max_prop.set_label("Fit2DNbIterMax");
	fit2_dnb_iter_max_prop.set_unit(" ");
	fit2_dnb_iter_max_prop.set_format("%5d");
	fit2_dnb_iter_max_prop.set_description("the maximal number of iteration to converge to a solution");
	fit2_dnb_iter_max->set_default_properties(fit2_dnb_iter_max_prop);
	fit2_dnb_iter_max->set_disp_level(Tango::EXPERT);
	att_list.push_back(fit2_dnb_iter_max);

	//	Attribute : Fit2DMaxRelChange
	Fit2DMaxRelChangeAttrib	*fit2_dmax_rel_change = new Fit2DMaxRelChangeAttrib();
	Tango::UserDefaultAttrProp	fit2_dmax_rel_change_prop;
	fit2_dmax_rel_change_prop.set_label("Fit2DMaxRelChange");
	fit2_dmax_rel_change_prop.set_unit(" ");
	fit2_dmax_rel_change_prop.set_format("%8.7f");
	fit2_dmax_rel_change_prop.set_description("optimization stops when the relative change between 2 iterations falls below this threshold");
	fit2_dmax_rel_change->set_default_properties(fit2_dmax_rel_change_prop);
	fit2_dmax_rel_change->set_disp_level(Tango::EXPERT);
	att_list.push_back(fit2_dmax_rel_change);

	//	Attribute : Fit1DNbIterMax
	Fit1DNbIterMaxAttrib	*fit1_dnb_iter_max = new Fit1DNbIterMaxAttrib();
	Tango::UserDefaultAttrProp	fit1_dnb_iter_max_prop;
	fit1_dnb_iter_max_prop.set_label("Fit1DNbIterMax");
	fit1_dnb_iter_max_prop.set_unit(" ");
	fit1_dnb_iter_max_prop.set_format("%5d");
	fit1_dnb_iter_max_prop.set_description("the maximal number of iteration to converge to a solution");
	fit1_dnb_iter_max->set_default_properties(fit1_dnb_iter_max_prop);
	fit1_dnb_iter_max->set_disp_level(Tango::EXPERT);
	att_list.push_back(fit1_dnb_iter_max);

	//	Attribute : Fit1DMaxRelChange
	Fit1DMaxRelChangeAttrib	*fit1_dmax_rel_change = new Fit1DMaxRelChangeAttrib();
	Tango::UserDefaultAttrProp	fit1_dmax_rel_change_prop;
	fit1_dmax_rel_change_prop.set_label("Fit1DMaxRelChange");
	fit1_dmax_rel_change_prop.set_unit(" ");
	fit1_dmax_rel_change_prop.set_format("%8.7f");
	fit1_dmax_rel_change_prop.set_description("optimization stops when the relative change between 2 iterations falls below this threshold");
	fit1_dmax_rel_change->set_default_properties(fit1_dmax_rel_change_prop);
	fit1_dmax_rel_change->set_disp_level(Tango::EXPERT);
	att_list.push_back(fit1_dmax_rel_change);

}

//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::get_class_property()
// 
// description : 	Read the class properties from database.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::get_class_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read class properties from database.(Automatic code generation)
	//------------------------------------------------------------------

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;


	//	End of Automatic code generation
	//------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 	ImgBeamAnalyzerClass::set_default_property
// 
// description: Set default property (class and device) for wizard.
//              For each property, add to wizard property name and description
//              If default value has been set, add it to wizard property and
//              store it in a DbDatum.
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;

	vector<string>	vect_data;
	//	Set Default Class Properties
	//	Set Default Device Properties
	prop_name = "AutoROIMagFactor";
	prop_desc = "initial value of AutoROIMagFactor attribute. if not defined, it is set to 1";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "AutoStart";
	prop_desc = "if set to 'true' and mode is 'CONTINUOUS', the computation starts automatically when the device is launched";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "ComputationPeriod";
	prop_desc = "the initial value of the ComputationPeriod attribute";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Enable2DGaussianFit";
	prop_desc = "the initial value of the Enable2DGaussianFit attribute";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableAutoROI";
	prop_desc = "the initial value of the EnableAutoROI attribute";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableImageStats";
	prop_desc = "the initial value of the EnableImageStats attribute";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableProfiles";
	prop_desc = "the initial value of the EnableProfiles attribute";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableUserROI";
	prop_desc = "the initial value of the EnableUserROI attribute";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "ImageAttributeName";
	prop_desc = "the name of the image attribute to take in ImageDevice";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "ImageDevice";
	prop_desc = "the device from which the image is taken";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Mode";
	prop_desc = "ONESHOT or CONTINUOUS";
	prop_def  = "ONESHOT";
	vect_data.clear();
	vect_data.push_back("ONESHOT");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "PixelSize";
	prop_desc = "the initial value of the PixelSize attribute";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Rotation";
	prop_desc = "the initial value of the Rotation attribute";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "HorizontalFlip";
	prop_desc = "the initial value of the HorizontalFlip attribute";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "GammaCorrection";
	prop_desc = "the initial value of the GammaCorrection attribute";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "BitsPerPixel";
	prop_desc = "the initial value of the BitsPerPixel attribute";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

}
//+----------------------------------------------------------------------------
//
// method : 		ImgBeamAnalyzerClass::write_class_property
// 
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void ImgBeamAnalyzerClass::write_class_property()
{
	//	First time, check if database used
	//--------------------------------------------
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Image Analyzer");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("The device analyzes images accessible on another remote device,");
	str_desc.push_back("and proposes the following (selectable) features :");
	str_desc.push_back("- in preprocessing : rotation, mirroring, gamma correction");
	str_desc.push_back("- ROI (Region Of Interest), either user-defined or automatic by blob analysis");
	str_desc.push_back("- image moments (mean intensity, centroid, variance, skew)");
	str_desc.push_back("- maximal intensity (to monitor saturation for example)");
	str_desc.push_back("- ellipse fitting when automatic ROI is desired");
	str_desc.push_back("- profiles with corresponding gaussian fit");
	str_desc.push_back("- 2D gaussian fit of the image");
	description << str_desc;
	data.push_back(description);
		
	//	put cvs location
	string	rcsId(RcsId);
	string	filename(classname);
	start = rcsId.find("/");
	if (start!=string::npos)
	{
		filename += "Class.cpp";
		end   = rcsId.find(filename);
		if (end>start)
		{
			string	strloc = rcsId.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	//	Get CVS tag revision
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//	Call database and and values
	//--------------------------------------------
	get_db_class()->put_property(data);
}

}	// namespace
